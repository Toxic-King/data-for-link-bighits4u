# ==============================================================================
# BigHits4U Viewer - Complete Automated System with Tailscale RDP
# ==============================================================================
#
# FEATURES:
# - Tailscale VPN for secure remote access
# - Remote Desktop (RDP) with custom credentials
# - Google Drive powered deployment (faster & more reliable)
# - ZIP-based software extraction (no GUI automation)
# - Auto-login with your BigHits4U credentials
# - 24/7 health monitoring with auto-restart
# - Enhanced retry mechanisms and error handling
#
# SETUP REQUIRED:
# 1. Add GitHub Secret: TAILSCALE_AUTH_KEY
#    - Go to https://login.tailscale.com/admin/settings/keys
#    - Create auth key (check "Reusable" and "Ephemeral")
#    - Add to GitHub: Settings > Secrets > Actions > New repository secret
#
# 2. Google Drive URLs: ✅ CONFIGURED
#    - BigHits4U Viewer ZIP: File ID 16Mrvq9NAxEuXgLM5ijS7jZm-RPpefIsG
#    - BigHits4U Cache ZIP: File ID 1Tp6VmT2GzNXp3NC5DEsrzok6-mJ3KN3Q
#    - Files are ready for download via direct Google Drive URLs
#
# ==============================================================================

name: BigHits4U with Tailscale RDP (Google Drive Enhanced)

on:
  workflow_dispatch:
    inputs:
      rdp_username:
        description: 'RDP Username'
        required: false
        default: 'Administrator'
        type: string
      rdp_password:
        description: 'RDP Password'
        required: false
        default: 'P@ssw0rd123!'
        type: string
      session_duration:
        description: 'Session duration in hours (max 6 hours)'
        required: false
        default: '6'
        type: string

jobs:
  automation:
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Initialize System
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "   BigHits4U Automation System Starting..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "Session Start: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" -ForegroundColor White
          Write-Host "Duration: ${{ github.event.inputs.session_duration }} hours" -ForegroundColor White
          Write-Host ""

          $sessionStart = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
          echo "SESSION_START=$sessionStart" >> $env:GITHUB_ENV

      - name: Configure Windows RDP
        run: |
          Write-Host "======================================================" -ForegroundColor Yellow
          Write-Host "Configuring Remote Desktop (RDP)..." -ForegroundColor Yellow
          Write-Host "======================================================" -ForegroundColor Yellow
          Write-Host ""

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
            -Name "fDenyTSConnections" -Value 0 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "UserAuthentication" -Value 0 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "SecurityLayer" -Value 1 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "KeepAliveEnable" -Value 1 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "KeepAliveInterval" -Value 1 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxIdleTime" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxDisconnectionTime" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxConnectionTime" -Value 0 -Force

          netsh advfirewall firewall delete rule name="RDP-Tailscale" 2>$null

          netsh advfirewall firewall add rule name="RDP-Tailscale" `
            dir=in action=allow protocol=TCP localport=3389 enable=yes

          Restart-Service -Name TermService -Force
          Start-Sleep -Seconds 6

          Write-Host "RDP configured successfully!" -ForegroundColor Green
          Write-Host ""

      - name: Create RDP User Account
        run: |
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host "Creating RDP User..." -ForegroundColor Magenta
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host ""

          $username = "${{ github.event.inputs.rdp_username }}"
          $password = "${{ github.event.inputs.rdp_password }}"

          if ([string]::IsNullOrWhiteSpace($username)) { $username = "Administrator" }
          if ([string]::IsNullOrWhiteSpace($password)) { $password = "P@ssw0rd123!" }

          secedit /export /cfg C:\secpol.cfg | Out-Null
          (Get-Content C:\secpol.cfg).replace("PasswordComplexity = 1", "PasswordComplexity = 0") | Out-File C:\secpol.cfg
          secedit /configure /db C:\Windows\security\local.sdb /cfg C:\secpol.cfg /areas SECURITYPOLICY | Out-Null
          Remove-Item -Force C:\secpol.cfg -Confirm:$false

          Remove-LocalUser -Name $username -ErrorAction SilentlyContinue

          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          New-LocalUser -Name $username -Password $securePass -PasswordNeverExpires -AccountNeverExpires | Out-Null

          Add-LocalGroupMember -Group "Administrators" -Member $username -ErrorAction SilentlyContinue
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username -ErrorAction SilentlyContinue

          echo "RDP_USERNAME=$username" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$password" >> $env:GITHUB_ENV

          Write-Host "User '$username' created successfully!" -ForegroundColor Green
          Write-Host "Password: $password" -ForegroundColor Cyan
          Write-Host ""

      - name: Install Tailscale VPN
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "Installing Tailscale VPN..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-latest-amd64.msi"
          $installerPath = "$env:TEMP\tailscale-latest.msi"

          Write-Host "Downloading Tailscale..." -ForegroundColor Yellow
          $ProgressPreference = 'SilentlyContinue'
          Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath -UseBasicParsing

          Write-Host "Installing..." -ForegroundColor Yellow
          $installArgs = @("/i", "`"$installerPath`"", "/quiet", "/norestart")
          $process = Start-Process msiexec.exe -ArgumentList $installArgs -Wait -PassThru

          if ($process.ExitCode -ne 0) {
            Write-Host "Tailscale installation failed!" -ForegroundColor Red
            exit 1
          }

          Start-Sleep -Seconds 10

          if (Test-Path "$env:ProgramFiles\Tailscale\tailscale.exe") {
            Write-Host "Tailscale installed successfully!" -ForegroundColor Green
          } else {
            Write-Host "Tailscale not found after installation!" -ForegroundColor Red
            exit 1
          }

          Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
          Write-Host ""

      - name: Connect to Tailscale Network
        run: |
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Connecting to Tailscale..." -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

          $authKey = "${{ secrets.TAILSCALE_AUTH_KEY }}"
          if ([string]::IsNullOrWhiteSpace($authKey)) {
            Write-Host "TAILSCALE_AUTH_KEY secret is not set!" -ForegroundColor Red
            Write-Host "" -ForegroundColor Yellow
            Write-Host "Setup Instructions:" -ForegroundColor Yellow
            Write-Host "1. Go to https://login.tailscale.com/admin/settings/keys" -ForegroundColor White
            Write-Host "2. Generate auth key (check 'Reusable' and 'Ephemeral')" -ForegroundColor White
            Write-Host "3. Add to GitHub: Settings > Secrets > Actions > New secret" -ForegroundColor White
            Write-Host "   Name: TAILSCALE_AUTH_KEY" -ForegroundColor White
            Write-Host "   Value: Your auth key" -ForegroundColor White
            exit 1
          }

          $hostname = "gh-bighits4u-$env:GITHUB_RUN_ID"

          Write-Host "Hostname: $hostname" -ForegroundColor Cyan
          Write-Host "Connecting..." -ForegroundColor Yellow

          $tsArgs = @("up", "--authkey=$authKey", "--hostname=$hostname", "--accept-routes", "--accept-dns=false", "--shields-up=false")
          & "$env:ProgramFiles\Tailscale\tailscale.exe" @tsArgs

          Write-Host "Waiting for IP assignment..." -ForegroundColor Yellow

          $tsIP = $null
          $maxRetries = 20
          $retryCount = 0

          while (-not $tsIP -and $retryCount -lt $maxRetries) {
            Start-Sleep -Seconds 6
            $tsIP = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
            $tsIP = $tsIP.Trim()

            if ($tsIP -match '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$') {
              break
            } else {
              $tsIP = $null
            }

            $retryCount++
          }

          if (-not $tsIP) {
            Write-Host "Failed to get Tailscale IP!" -ForegroundColor Red
            exit 1
          }

          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV
          echo "TAILSCALE_HOSTNAME=$hostname" >> $env:GITHUB_ENV

          Write-Host "Connected!" -ForegroundColor Green
          Write-Host "Tailscale IP: $tsIP" -ForegroundColor Cyan
          Write-Host ""

      - name: Download and Extract BigHits4U Viewer
        id: install
        run: |
          Write-Host "========================================================" -ForegroundColor Cyan
          Write-Host "=     BigHits4U Viewer Google Drive Installer         =" -ForegroundColor Cyan
          Write-Host "========================================================" -ForegroundColor Cyan
          Write-Host ""

          # Enhanced Configuration
          $InstallPath = "$env:ProgramFiles\Bighits4u Viewer"
          $downloadUrl = "https://drive.google.com/uc?id=16Mrvq9NAxEuXgLM5ijS7jZm-RPpefIsG&export=download"
          $zipPath = "$env:TEMP\Bighits4u_Viewer.zip"
          $executableName = "BigHits4UViewer.exe"
          $downloadTimeout = 600
          $maxRetries = 3
          $retryDelay = 10
          $script:installedPath = $null

          try {
            # Check if already extracted
            Write-Host "[INFO] Checking for existing installation..." -ForegroundColor Yellow

            $existingPaths = @(
              "$InstallPath\$executableName",
              "$env:ProgramFiles\Bighits4u Viewer\$executableName",
              "${env:ProgramFiles(x86)}\Bighits4u Viewer\$executableName",
              "$env:LOCALAPPDATA\Bighits4u Viewer\$executableName",
              "$env:APPDATA\Bighits4u Viewer\$executableName"
            )

            foreach ($path in $existingPaths) {
              if (Test-Path $path) {
                Write-Host "= BigHits4U Viewer already installed!" -ForegroundColor Green
                Write-Host "   Location: $path" -ForegroundColor Gray
                $script:installedPath = $path
                break
              }
            }

            if (-not $script:installedPath) {
              Write-Host "   No existing installation found" -ForegroundColor Gray
              Write-Host "   Proceeding with Google Drive download and extraction..." -ForegroundColor Gray
              Write-Host ""

              # Install Python and gdown for reliable Google Drive downloads
              Write-Host "[SETUP] Installing Python and gdown for Google Drive..." -ForegroundColor Yellow
              
              try {
                # Check if Python is available
                $pythonVersion = python --version 2>$null
                if (-not $pythonVersion) {
                  Write-Host "   Installing Python..." -ForegroundColor Gray
                  # Download and install Python silently
                  $pythonUrl = "https://www.python.org/ftp/python/3.11.0/python-3.11.0-amd64.exe"
                  $pythonInstaller = "$env:TEMP\python-installer.exe"
                  Invoke-WebRequest -Uri $pythonUrl -OutFile $pythonInstaller -UseBasicParsing
                  Start-Process -FilePath $pythonInstaller -ArgumentList "/quiet", "InstallAllUsers=1", "PrependPath=1" -Wait
                  Remove-Item $pythonInstaller -Force -ErrorAction SilentlyContinue
                  
                  # Refresh PATH
                  $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH", "User")
                }
                
                Write-Host "   Installing gdown..." -ForegroundColor Gray
                python -m pip install --upgrade pip gdown --quiet
                
                Write-Host "   ✓ gdown installed successfully" -ForegroundColor Green
              } catch {
                Write-Host "   Warning: Could not install gdown, falling back to alternative method" -ForegroundColor Yellow
              }

              # Download from Google Drive with multiple methods
              Write-Host "[DOWNLOAD] Downloading BigHits4U Viewer ZIP from Google Drive..." -ForegroundColor Yellow
              Write-Host "   File ID: 16Mrvq9NAxEuXgLM5ijS7jZm-RPpefIsG" -ForegroundColor Gray
              Write-Host "   Destination: $zipPath" -ForegroundColor Gray

              if (Test-Path $zipPath) {
                Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
              }

              $ProgressPreference = 'SilentlyContinue'
              $downloadAttempt = 0
              $downloadSuccess = $false
              $fileId = "16Mrvq9NAxEuXgLM5ijS7jZm-RPpefIsG"

              while ($downloadAttempt -lt $maxRetries -and -not $downloadSuccess) {
                $downloadAttempt++
                Write-Host "   Download attempt $downloadAttempt/$maxRetries" -ForegroundColor Gray

                try {
                  # Method 1: Try gdown (most reliable)
                  Write-Host "   [METHOD 1] Trying gdown..." -ForegroundColor Gray
                  $gdownResult = python -m gdown "https://drive.google.com/uc?id=$fileId" -O "$zipPath" --quiet 2>&1
                  
                  if (Test-Path $zipPath -and (Get-Item $zipPath).Length -gt 1MB) {
                    $downloadSuccess = $true
                    Write-Host "   [SUCCESS] gdown download completed" -ForegroundColor Green
                  } else {
                    throw "gdown failed or file too small"
                  }

                } catch {
                  Write-Host "   [METHOD 1] gdown failed: $($_.Exception.Message)" -ForegroundColor Yellow
                  
                  try {
                    # Method 2: Try curl (more reliable than WebClient)
                    Write-Host "   [METHOD 2] Trying curl..." -ForegroundColor Gray
                    
                    if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
                    
                    $curlArgs = @(
                      "-L",
                      "-o", $zipPath,
                      "-H", "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                      "--max-time", "600",
                      "https://drive.google.com/uc?export=download&id=$fileId"
                    )
                    
                    $curlProcess = Start-Process -FilePath "curl" -ArgumentList $curlArgs -Wait -PassThru -NoNewWindow
                    
                    if ($curlProcess.ExitCode -eq 0 -and (Test-Path $zipPath) -and (Get-Item $zipPath).Length -gt 1MB) {
                      $downloadSuccess = $true
                      Write-Host "   [SUCCESS] curl download completed" -ForegroundColor Green
                    } else {
                      throw "curl failed or file too small"
                    }
                    
                  } catch {
                    Write-Host "   [METHOD 2] curl failed: $($_.Exception.Message)" -ForegroundColor Yellow
                    
                    # Method 3: PowerShell Invoke-WebRequest with session handling
                    Write-Host "   [METHOD 3] Trying PowerShell with session..." -ForegroundColor Gray
                    
                    if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
                    
                    $session = New-Object Microsoft.PowerShell.Commands.WebRequestSession
                    $session.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                    
                    # Try multiple URL formats
                    $urls = @(
                      "https://drive.google.com/uc?export=download&id=$fileId",
                      "https://drive.google.com/file/d/$fileId/view?usp=drive_link",
                      "https://drive.usercontent.google.com/download?id=$fileId&export=download"
                    )
                    
                    foreach ($url in $urls) {
                      try {
                        Write-Host "   Trying URL: $url" -ForegroundColor DarkGray
                        Invoke-WebRequest -Uri $url -OutFile $zipPath -WebSession $session -TimeoutSec 600 -UseBasicParsing
                        
                        if ((Get-Item $zipPath -ErrorAction SilentlyContinue).Length -gt 1MB) {
                          $downloadSuccess = $true
                          Write-Host "   [SUCCESS] PowerShell download completed" -ForegroundColor Green
                          break
                        }
                      } catch {
                        Write-Host "   URL failed: $($_.Exception.Message)" -ForegroundColor DarkGray
                        continue
                      }
                    }
                    
                    if (-not $downloadSuccess) {
                      throw "All download methods failed"
                    }
                  }
                }

                if (-not $downloadSuccess -and $downloadAttempt -lt $maxRetries) {
                  Write-Host "   Waiting $retryDelay seconds before retry..." -ForegroundColor Gray
                  Start-Sleep -Seconds $retryDelay
                }
              }

              if (-not $downloadSuccess) {
                throw "Download failed after $maxRetries attempts with all methods"
              }

              if (-not (Test-Path $zipPath)) {
                throw "Download failed - ZIP file not found"
              }

              $fileSize = [math]::Round((Get-Item $zipPath).Length / 1MB, 2)

              if ($fileSize -lt 10) {
                Remove-Item $zipPath -Force
                throw "Downloaded ZIP file is too small ($fileSize MB) - possibly corrupt"
              }

              Write-Host "= Download complete! (Size: $fileSize MB)" -ForegroundColor Green
              Write-Host ""

              # Extract ZIP file directly (no installation needed)
              Write-Host "[EXTRACT] Extracting BigHits4U Viewer ZIP..." -ForegroundColor Yellow
              Write-Host "   Source: $zipPath" -ForegroundColor Gray
              Write-Host "   Target: $InstallPath" -ForegroundColor Gray
              Write-Host ""

              $extractionSuccess = $false
              $extractMethod = "PowerShell Extraction"

              try {
                # Ensure target directory exists
                if (-not (Test-Path $InstallPath)) {
                  New-Item -Path $InstallPath -ItemType Directory -Force | Out-Null
                  Write-Host "   Created installation directory" -ForegroundColor Gray
                }

                # Load compression assembly and extract
                Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
                
                Write-Host "[STEP 1] Extracting ZIP archive..." -ForegroundColor Cyan
                [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $InstallPath)
                
                Write-Host "[STEP 2] Verifying extraction..." -ForegroundColor Cyan
                $possiblePaths = @(
                  "$InstallPath\Bighits4u Viewer\$executableName",
                  "$InstallPath\$executableName"
                )
                
                foreach ($path in $possiblePaths) {
                  if (Test-Path $path) {
                    $script:installedPath = $path
                    $extractionSuccess = $true
                    Write-Host "   = Found extracted executable: $path" -ForegroundColor Green
                    break
                  }
                }
                
                if (-not $extractionSuccess) {
                  Write-Host "   Performing deep search..." -ForegroundColor Yellow
                  $found = Get-ChildItem -Path $InstallPath -Filter $executableName -Recurse -ErrorAction SilentlyContinue |
                           Where-Object { $_.PSIsContainer -eq $false } |
                           Select-Object -First 1
                  if ($found) {
                    $script:installedPath = $found.FullName
                    $extractionSuccess = $true
                    Write-Host "   = Found via deep search: $script:installedPath" -ForegroundColor Green
                  }
                }
                
              } catch {
                Write-Host "   [ERROR] ZIP extraction failed: $_" -ForegroundColor Red
                throw "Extraction failed: $_"
              }

              if (-not $extractionSuccess) {
                throw "Extraction failed - executable not found after extraction"
              }

              Write-Host "= Extraction completed successfully!" -ForegroundColor Green
              Write-Host "  Method: $extractMethod | Path: $script:installedPath" -ForegroundColor Cyan

              # Cleanup ZIP file
              if (Test-Path $zipPath) {
                Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
                Write-Host "   ZIP file cleaned up" -ForegroundColor Gray
              }
            }

            # Final verification
            if ($script:installedPath -and (Test-Path $script:installedPath)) {
              Write-Host ""
              Write-Host "= BigHits4U Viewer extracted successfully!" -ForegroundColor Green
              Write-Host "   Executable: $script:installedPath" -ForegroundColor Gray

              $fileInfo = Get-Item $script:installedPath
              if ($fileInfo.Length -lt 102400) {
                throw "Extracted executable is suspiciously small"
              }

              $installDir = Split-Path $script:installedPath -Parent

              echo "SOFTWARE_PATH=$script:installedPath" >> $env:GITHUB_ENV
              echo "SOFTWARE_DIR=$installDir" >> $env:GITHUB_ENV

              Write-Host ""
              Write-Host "========================================================" -ForegroundColor Green
              Write-Host "=     EXTRACTION SUCCESSFUL!                          =" -ForegroundColor Green
              Write-Host "========================================================" -ForegroundColor Green
              Write-Host ""
            } else {
              throw "Extraction verification failed - executable not found"
            }

          } catch {
            Write-Host ""
            Write-Host "========================================================" -ForegroundColor Red
            Write-Host "=     EXTRACTION FAILED                               =" -ForegroundColor Red
            Write-Host "========================================================" -ForegroundColor Red
            Write-Host ""
            Write-Host "Error: $_" -ForegroundColor Red
            exit 1
          }

      - name: Download and Extract BigHits4U Cache
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "Downloading BigHits4U Cache from Google Drive..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

          # Configuration
          $cacheDownloadUrl = "https://drive.google.com/uc?id=1Tp6VmT2GzNXp3NC5DEsrzok6-mJ3KN3Q&export=download"
          $cacheZipPath = "$env:TEMP\BigHits4U_Cache.zip"
          $maxRetries = 3
          $retryDelay = 10
          $downloadTimeout = 300
          
          $rdpUsername = "${{ github.event.inputs.rdp_username }}"
          if ([string]::IsNullOrWhiteSpace($rdpUsername)) { $rdpUsername = "Administrator" }
          
          # Determine the correct user profile path
          $targetBasePath = "C:\Users\$rdpUsername\AppData\Local"
          
          # Use current user's AppData if RDP user path doesn't exist
          if (-not (Test-Path $targetBasePath)) {
            $targetBasePath = "$env:LOCALAPPDATA"
            Write-Host "Using current user AppData: $targetBasePath" -ForegroundColor Yellow
          } else {
            Write-Host "Using RDP user AppData: $targetBasePath" -ForegroundColor Green
          }
          
          $targetPath = "$targetBasePath\BigHits4U"
          
          Write-Host "Cache ZIP URL: $cacheDownloadUrl" -ForegroundColor Gray
          Write-Host "Download Path: $cacheZipPath" -ForegroundColor Gray
          Write-Host "Extract Target: $targetPath" -ForegroundColor Gray
          Write-Host ""
          
          try {
            # Download BigHits4U cache ZIP with multiple methods
            Write-Host "[DOWNLOAD] Downloading BigHits4U Cache ZIP..." -ForegroundColor Yellow
            Write-Host "   File ID: 1Tp6VmT2GzNXp3NC5DEsrzok6-mJ3KN3Q" -ForegroundColor Gray
            
            if (Test-Path $cacheZipPath) {
              Remove-Item $cacheZipPath -Force -ErrorAction SilentlyContinue
            }
              
            $ProgressPreference = 'SilentlyContinue'
            $downloadAttempt = 0
            $downloadSuccess = $false
            $cacheFileId = "1Tp6VmT2GzNXp3NC5DEsrzok6-mJ3KN3Q"
            
            while ($downloadAttempt -lt $maxRetries -and -not $downloadSuccess) {
              $downloadAttempt++
              Write-Host "   Cache download attempt $downloadAttempt/$maxRetries" -ForegroundColor Gray
              
              try {
                # Method 1: Try gdown for cache
                Write-Host "   [METHOD 1] Trying gdown for cache..." -ForegroundColor Gray
                $gdownResult = python -m gdown "https://drive.google.com/uc?id=$cacheFileId" -O "$cacheZipPath" --quiet 2>&1
                
                if (Test-Path $cacheZipPath -and (Get-Item $cacheZipPath).Length -gt 100) {
                  $downloadSuccess = $true
                  Write-Host "   [SUCCESS] gdown cache download completed" -ForegroundColor Green
                } else {
                  throw "gdown cache failed or file too small"
                }

              } catch {
                Write-Host "   [METHOD 1] gdown cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                
                try {
                  # Method 2: Try curl for cache
                  Write-Host "   [METHOD 2] Trying curl for cache..." -ForegroundColor Gray
                  
                  if (Test-Path $cacheZipPath) { Remove-Item $cacheZipPath -Force }
                  
                  $curlArgs = @(
                    "-L",
                    "-o", $cacheZipPath,
                    "-H", "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    "--max-time", "300",
                    "https://drive.google.com/uc?export=download&id=$cacheFileId"
                  )
                  
                  $curlProcess = Start-Process -FilePath "curl" -ArgumentList $curlArgs -Wait -PassThru -NoNewWindow
                  
                  if ($curlProcess.ExitCode -eq 0 -and (Test-Path $cacheZipPath) -and (Get-Item $cacheZipPath).Length -gt 100) {
                    $downloadSuccess = $true
                    Write-Host "   [SUCCESS] curl cache download completed" -ForegroundColor Green
                  } else {
                    throw "curl cache failed or file too small"
                  }
                  
                } catch {
                  Write-Host "   [METHOD 2] curl cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                  
                  # Method 3: PowerShell for cache
                  Write-Host "   [METHOD 3] Trying PowerShell for cache..." -ForegroundColor Gray
                  
                  if (Test-Path $cacheZipPath) { Remove-Item $cacheZipPath -Force }
                  
                  $session = New-Object Microsoft.PowerShell.Commands.WebRequestSession
                  $session.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                  
                  $cacheUrls = @(
                    "https://drive.google.com/uc?export=download&id=$cacheFileId",
                    "https://drive.usercontent.google.com/download?id=$cacheFileId&export=download"
                  )
                  
                  foreach ($url in $cacheUrls) {
                    try {
                      Write-Host "   Trying cache URL: $url" -ForegroundColor DarkGray
                      Invoke-WebRequest -Uri $url -OutFile $cacheZipPath -WebSession $session -TimeoutSec 300 -UseBasicParsing
                      
                      if ((Get-Item $cacheZipPath -ErrorAction SilentlyContinue).Length -gt 100) {
                        $downloadSuccess = $true
                        Write-Host "   [SUCCESS] PowerShell cache download completed" -ForegroundColor Green
                        break
                      }
                    } catch {
                      Write-Host "   Cache URL failed: $($_.Exception.Message)" -ForegroundColor DarkGray
                      continue
                    }
                  }
                  
                  if (-not $downloadSuccess) {
                    throw "All cache download methods failed"
                  }
                }
              }

              if (-not $downloadSuccess -and $downloadAttempt -lt $maxRetries) {
                Write-Host "   Waiting $retryDelay seconds before cache retry..." -ForegroundColor Gray
                Start-Sleep -Seconds $retryDelay
              }
            }

            if (-not $downloadSuccess) {
              throw "Cache download failed after $maxRetries attempts with all methods"
            }
            
            # Verify download
            if (-not (Test-Path $cacheZipPath)) {
              throw "Cache download failed - ZIP file not found"
            }
            
            $fileSize = [math]::Round((Get-Item $cacheZipPath).Length / 1KB, 2)
            Write-Host "   Downloaded cache size: $fileSize KB" -ForegroundColor Cyan
            Write-Host ""
            
            # Remove existing cache if present
            if (Test-Path $targetPath) {
              Write-Host "[CLEANUP] Removing existing BigHits4U cache..." -ForegroundColor Yellow
              Remove-Item $targetPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            
            # Extract cache ZIP
            Write-Host "[EXTRACT] Extracting BigHits4U Cache..." -ForegroundColor Yellow
            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
            [System.IO.Compression.ZipFile]::ExtractToDirectory($cacheZipPath, $targetBasePath)
            
            Write-Host "   ✓ Cache extracted successfully!" -ForegroundColor Green
            
            # Cleanup ZIP file
            if (Test-Path $cacheZipPath) {
              Remove-Item $cacheZipPath -Force -ErrorAction SilentlyContinue
              Write-Host "   Cache ZIP file cleaned up" -ForegroundColor Gray
            }
            
          } catch {
            Write-Host "ERROR: Failed to download/extract cache: $_" -ForegroundColor Red
            exit 1
          }
          
          # Verify copy
          if (Test-Path $targetPath) {
            $targetItems = Get-ChildItem $targetPath -Recurse | Measure-Object
            Write-Host "Target folder contains: $($targetItems.Count) items" -ForegroundColor Cyan
            
            # Verify critical files
            $criticalFiles = @(
              "$targetPath\setting\setting.ini",
              "$targetPath\Bighits4u1\Cookies",
              "$targetPath\Bighits4u1\LocalPrefs.json"
            )
            
            $allCriticalFilesExist = $true
            foreach ($file in $criticalFiles) {
              if (Test-Path $file) {
                Write-Host "  ✓ Found: $(Split-Path $file -Leaf)" -ForegroundColor Green
              } else {
                Write-Host "  ✗ Missing: $(Split-Path $file -Leaf)" -ForegroundColor Red
                $allCriticalFilesExist = $false
              }
            }
            
            if ($allCriticalFilesExist) {
              Write-Host ""
              Write-Host "======================================================" -ForegroundColor Green
              Write-Host "  CACHE CONFIGURED SUCCESSFULLY!" -ForegroundColor Green
              Write-Host "======================================================" -ForegroundColor Green
              Write-Host "BigHits4U will auto-login using cached session!" -ForegroundColor White
              Write-Host ""
            } else {
              Write-Host ""
              Write-Host "WARNING: Some critical files are missing!" -ForegroundColor Yellow
              Write-Host "BigHits4U may not auto-login properly." -ForegroundColor Yellow
              Write-Host ""
            }
          } else {
            Write-Host "ERROR: Target folder not found after copy!" -ForegroundColor Red
            exit 1
          }
          
          # Store path for later use
          echo "BIGHITS4U_CACHE_PATH=$targetPath" >> $env:GITHUB_ENV

      - name: Start BigHits4U Viewer
        run: |
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Starting BigHits4U Viewer..." -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

          $softwarePath = $env:SOFTWARE_PATH
          $workingDir = $env:SOFTWARE_DIR

          $processInfo = New-Object System.Diagnostics.ProcessStartInfo
          $processInfo.FileName = $softwarePath
          $processInfo.WorkingDirectory = $workingDir
          $processInfo.UseShellExecute = $true
          $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal

          $process = [System.Diagnostics.Process]::Start($processInfo)

          if ($process) {
            $processId = $process.Id
            echo "SOFTWARE_PID=$processId" >> $env:GITHUB_ENV

            Write-Host "BigHits4U Viewer started!" -ForegroundColor Green
            Write-Host "Process ID: $processId" -ForegroundColor White
            Write-Host ""

            Start-Sleep -Seconds 20

            $runningProcess = Get-Process -Id $processId -ErrorAction SilentlyContinue

            if ($runningProcess) {
              Write-Host "Process running and stable!" -ForegroundColor Green
            } else {
              Write-Host "Process may be running in background" -ForegroundColor Yellow
            }
          } else {
            Write-Host "Failed to start BigHits4U Viewer!" -ForegroundColor Red
            exit 1
          }

          Write-Host ""

      - name: Wait for Login Verification
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "Verifying Cache-Based Auto-Login..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

          $maxWaitSeconds = 180
          $waitedSeconds = 0
          $checkInterval = 10
          $loginSuccess = $false

          Write-Host "Waiting for BigHits4U to complete authentication..." -ForegroundColor Yellow
          Write-Host "This may take up to 3 minutes" -ForegroundColor Gray
          Write-Host ""

          while ($waitedSeconds -lt $maxWaitSeconds -and -not $loginSuccess) {
            Start-Sleep -Seconds $checkInterval
            $waitedSeconds += $checkInterval

            $process = Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue

            if ($process) {
              $windowTitle = $process.MainWindowTitle
              $memMB = [math]::Round($process.WorkingSet64 / 1MB, 2)
              $responding = $process.Responding

              Write-Host "[${waitedSeconds}s] Checking status..." -ForegroundColor Gray
              Write-Host "  Window Title: '$windowTitle'" -ForegroundColor White
              Write-Host "  Memory: ${memMB} MB" -ForegroundColor White
              Write-Host "  Responding: $responding" -ForegroundColor $(if($responding){"Green"}else{"Yellow"})

              # Check if logged in (window title contains pipe character and username/IP)
              if ($windowTitle -match '\|') {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Green
                Write-Host "✅ LOGIN SUCCESSFUL!" -ForegroundColor Green
                Write-Host "======================================================" -ForegroundColor Green
                Write-Host "Window title indicates user is logged in:" -ForegroundColor White
                Write-Host "  $windowTitle" -ForegroundColor Cyan
                Write-Host ""
                Write-Host "BigHits4U is now actively earning points!" -ForegroundColor Green
                Write-Host "Total login time: ${waitedSeconds} seconds" -ForegroundColor Gray
                Write-Host ""
                $loginSuccess = $true
                break
              } else {
                Write-Host "  Status: Still authenticating..." -ForegroundColor Yellow
                Write-Host ""
              }
            } else {
              Write-Host ""
              Write-Host "⚠️  Process not found!" -ForegroundColor Red
              Write-Host "BigHits4U may have crashed during startup" -ForegroundColor Red
              exit 1
            }
          }

          if (-not $loginSuccess) {
            Write-Host ""
            Write-Host "======================================================" -ForegroundColor Red
            Write-Host "❌ LOGIN VERIFICATION TIMEOUT" -ForegroundColor Red
            Write-Host "======================================================" -ForegroundColor Red
            Write-Host "BigHits4U did not log in after ${maxWaitSeconds} seconds" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "Possible issues:" -ForegroundColor White
            Write-Host "  1. Cache files may be corrupted or invalid" -ForegroundColor Gray
            Write-Host "  2. Network connectivity issues" -ForegroundColor Gray
            Write-Host "  3. BigHits4U server is down" -ForegroundColor Gray
            Write-Host "  4. Account credentials in cache expired" -ForegroundColor Gray
            Write-Host ""
            Write-Host "Last known window title: '$windowTitle'" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "⚠️  Proceeding anyway - check RDP for manual verification" -ForegroundColor Yellow
            Write-Host "RDP Connection: $env:TAILSCALE_IP" -ForegroundColor Cyan
          }

          # Store login timestamp
          echo "LOGIN_VERIFIED_TIME=$(Get-Date -Format 'o')" >> $env:GITHUB_ENV
          echo "LOGIN_SUCCESS=$loginSuccess" >> $env:GITHUB_ENV

      - name: Display Connection Information
        run: |
          Write-Host ""
          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "          SYSTEM READY AND OPERATIONAL" -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "TAILSCALE RDP CONNECTION:" -ForegroundColor White
          Write-Host "  IP Address:  $env:TAILSCALE_IP" -ForegroundColor Yellow
          Write-Host "  Hostname:    $env:TAILSCALE_HOSTNAME" -ForegroundColor Yellow
          Write-Host "  RDP Port:    3389" -ForegroundColor Yellow
          Write-Host "  Username:    $env:RDP_USERNAME" -ForegroundColor Yellow
          Write-Host "  Password:    $env:RDP_PASSWORD" -ForegroundColor Yellow
          Write-Host ""
          Write-Host "BIGHITS4U VIEWER:" -ForegroundColor White
          Write-Host "  Status:      Running with Cache-Based Auto-Login" -ForegroundColor Green
          Write-Host "  Cache:       Pre-configured session from GitHub repository" -ForegroundColor Green
          Write-Host "  Duration:    ${{ github.event.inputs.session_duration }} hours" -ForegroundColor Green
          Write-Host ""
          Write-Host "HOW TO CONNECT:" -ForegroundColor White
          Write-Host "  1. Install Tailscale: tailscale.com/download" -ForegroundColor Gray
          Write-Host "  2. Connect to your Tailscale network" -ForegroundColor Gray
          Write-Host "  3. Open Remote Desktop Connection (mstsc)" -ForegroundColor Gray
          Write-Host "  4. Enter IP: $env:TAILSCALE_IP" -ForegroundColor Gray
          Write-Host "  5. Login with credentials above" -ForegroundColor Gray
          Write-Host "  6. BigHits4U will be running automatically!" -ForegroundColor Gray
          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

      - name: Health Monitoring and Keep-Alive
        run: |
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host "Starting Health Monitoring..." -ForegroundColor Magenta
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host ""

          $sessionDuration = [int]"${{ github.event.inputs.session_duration }}"
          if ($sessionDuration -eq 0 -or $sessionDuration -gt 6) {
            $sessionDuration = 6
            Write-Host "Duration capped at 6 hours (GitHub Actions limit)" -ForegroundColor Yellow
          }

          $sessionStart = Get-Date
          $endTime = $sessionStart.AddHours($sessionDuration)
          $checkInterval = 300
          $iteration = 0

          $softwarePath = $env:SOFTWARE_PATH
          $workingDir = $env:SOFTWARE_DIR

          Write-Host "Session will run until: $($endTime.ToString('yyyy-MM-dd HH:mm:ss'))" -ForegroundColor Yellow
          Write-Host "Health check interval: 5 minutes" -ForegroundColor Yellow
          Write-Host ""

          # Initialize crash tracking
          $restartCount = 0
          $lastRestartTime = $null
          $maxMemoryMB = 0
          $consecutiveNotResponding = 0

          while ((Get-Date) -lt $endTime) {
            $iteration++
            $now = Get-Date
            $elapsed = $now - $sessionStart
            $remaining = $endTime - $now

            $elapsedDays = [math]::Floor($elapsed.TotalDays)
            $elapsedHours = $elapsed.Hours
            $elapsedMins = $elapsed.Minutes

            $remainingDays = [math]::Floor($remaining.TotalDays)
            $remainingHours = $remaining.Hours
            $remainingMins = $remaining.Minutes

            Write-Host "======================================================" -ForegroundColor DarkGray
            Write-Host "Health Check #$iteration at $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Cyan
            Write-Host "Status: ACTIVE | Restarts: $restartCount" -ForegroundColor Green
            Write-Host "Uptime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
            Write-Host "Remaining: ${remainingDays}d ${remainingHours}h ${remainingMins}m" -ForegroundColor White
            Write-Host ""

            $process = Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue

            if ($process) {
              # Process is running - perform health checks
              $cpu = [math]::Round($process.CPU, 2)
              $memMB = [math]::Round($process.WorkingSet64 / 1MB, 2)
              $responding = $process.Responding
              $windowTitle = $process.MainWindowTitle
              $hasWindow = $process.MainWindowHandle -ne 0
              $isLoggedIn = $windowTitle -match '\|'

              # Track peak memory usage
              if ($memMB -gt $maxMemoryMB) { $maxMemoryMB = $memMB }

              Write-Host "BigHits4U Viewer: RUNNING" -ForegroundColor Green
              Write-Host "  PID: $($process.Id)" -ForegroundColor Gray
              Write-Host "  Window: $windowTitle" -ForegroundColor $(if($isLoggedIn){"Green"}else{"Yellow"})
              Write-Host "  CPU Time: ${cpu}s" -ForegroundColor Gray
              Write-Host "  Memory: ${memMB} MB (Peak: ${maxMemoryMB} MB)" -ForegroundColor Gray
              Write-Host "  Responding: $responding" -ForegroundColor $(if($responding){"Green"}else{"Red"})
              Write-Host "  Login Status: $(if($isLoggedIn){'✓ Logged In'}else{'⚠ Not Logged In'})" -ForegroundColor $(if($isLoggedIn){"Green"}else{"Yellow"})

              # Check for abnormal conditions
              $needsRestart = $false
              $restartReason = ""

              # Check 1: Process not responding (requires 2 consecutive failures)
              if (-not $responding) {
                $consecutiveNotResponding++
                Write-Host "  ⚠️  Warning: Process not responding ($consecutiveNotResponding/2)" -ForegroundColor Yellow
                
                if ($consecutiveNotResponding -ge 2) {
                  $needsRestart = $true
                  $restartReason = "Process frozen for 10+ minutes (2 consecutive checks)"
                }
              } else {
                # Reset counter if responding
                if ($consecutiveNotResponding -gt 0) {
                  Write-Host "  ✓ Process recovered from not-responding state" -ForegroundColor Green
                  $consecutiveNotResponding = 0
                }
              }

              # Check 2: Excessive memory usage (raised threshold to 2GB)
              if ($memMB -gt 2000) {
                $needsRestart = $true
                $restartReason = "Memory leak detected (${memMB} MB > 2000 MB threshold)"
              }

              # REMOVED: Window handle check - it was too aggressive and killed working processes

              if ($needsRestart) {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Yellow
                Write-Host "⚠️  ABNORMAL STATE DETECTED" -ForegroundColor Yellow
                Write-Host "======================================================" -ForegroundColor Yellow
                Write-Host "Reason: $restartReason" -ForegroundColor White
                Write-Host "Performing preventive restart..." -ForegroundColor Yellow
                Write-Host ""
                
                # Reset consecutive counter
                $consecutiveNotResponding = 0
                
                try {
                  Stop-Process -Id $process.Id -Force -ErrorAction Stop
                  Write-Host "  ✓ Process terminated" -ForegroundColor Gray
                  Start-Sleep -Seconds 3
                } catch {
                  Write-Host "  ⚠️  Warning: Could not stop process: $_" -ForegroundColor Yellow
                }
              } else {
                # All checks passed - log healthy status
                if ($iteration % 6 -eq 0) {
                  Write-Host "  ✅ All health checks passed - system healthy" -ForegroundColor Green
                }
              }

            } else {
              # Process crashed or stopped - perform restart
              Write-Host "BigHits4U Viewer: STOPPED" -ForegroundColor Red
              Write-Host "Initiating automatic restart..." -ForegroundColor Yellow
              Write-Host ""

              $restartAttempts = 0
              $maxRestartAttempts = 3
              $restartSuccess = $false

              while ($restartAttempts -lt $maxRestartAttempts -and -not $restartSuccess) {
                $restartAttempts++
                Write-Host "Restart attempt $restartAttempts/$maxRestartAttempts..." -ForegroundColor Cyan

                try {
                  # Clean up any orphaned processes
                  Get-Process | Where-Object { $_.ProcessName -like "*BigHits*" } | 
                    ForEach-Object {
                      Write-Host "  Cleaning up orphaned process: $($_.ProcessName) (PID: $($_.Id))" -ForegroundColor Gray
                      Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
                    }
                  Start-Sleep -Seconds 2

                  # Start the application
                  $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                  $processInfo.FileName = $softwarePath
                  $processInfo.WorkingDirectory = $workingDir
                  $processInfo.UseShellExecute = $true
                  $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal

                  $newProcess = [System.Diagnostics.Process]::Start($processInfo)

                  if ($newProcess) {
                    Write-Host "  ✓ Process started (PID: $($newProcess.Id))" -ForegroundColor Green
                    Start-Sleep -Seconds 15

                    # Verify the process is still running
                    $verifyProcess = Get-Process -Id $newProcess.Id -ErrorAction SilentlyContinue
                    if ($verifyProcess) {
                      Write-Host "  ✓ Process verified and stable" -ForegroundColor Green
                      Write-Host "  ✓ Cache-based auto-login active" -ForegroundColor Green
                      $restartSuccess = $true
                      $restartCount++
                      $lastRestartTime = Get-Date
                      $consecutiveNotResponding = 0
                    } else {
                      Write-Host "  ✗ Process died immediately after start" -ForegroundColor Red
                    }
                  } else {
                    Write-Host "  ✗ Failed to start process" -ForegroundColor Red
                  }
                } catch {
                  Write-Host "  ✗ Restart error: $_" -ForegroundColor Red
                }

                if (-not $restartSuccess -and $restartAttempts -lt $maxRestartAttempts) {
                  Write-Host "  Waiting 10 seconds before retry..." -ForegroundColor Yellow
                  Start-Sleep -Seconds 10
                }
              }

              if (-not $restartSuccess) {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Red
                Write-Host "CRITICAL: Unable to restart after $maxRestartAttempts attempts" -ForegroundColor Red
                Write-Host "======================================================" -ForegroundColor Red
                Write-Host "The software may require manual intervention" -ForegroundColor Yellow
                Write-Host "Connect via RDP to investigate: $env:TAILSCALE_IP" -ForegroundColor Cyan
              }
            }

            Write-Host ""

            $rdpService = Get-Service -Name TermService -ErrorAction SilentlyContinue
            if ($rdpService.Status -eq 'Running') {
              Write-Host "RDP Service: Running" -ForegroundColor Green
            } else {
              Write-Host "RDP Service: Stopped - Restarting..." -ForegroundColor Red
              Restart-Service -Name TermService -Force
            }

            $tsStatus = & "$env:ProgramFiles\Tailscale\tailscale.exe" status --json 2>$null | ConvertFrom-Json
            if ($tsStatus) {
              Write-Host "Tailscale: Connected ($env:TAILSCALE_IP)" -ForegroundColor Green
            } else {
              Write-Host "Tailscale: Status unknown" -ForegroundColor Yellow
            }

            Write-Host ""

            $memInfo = Get-CimInstance Win32_OperatingSystem
            $totalMemGB = [math]::Round($memInfo.TotalVisibleMemorySize / 1MB, 2)
            $freeMemGB = [math]::Round($memInfo.FreePhysicalMemory / 1MB, 2)
            $usedMemPercent = [math]::Round((($memInfo.TotalVisibleMemorySize - $memInfo.FreePhysicalMemory) / $memInfo.TotalVisibleMemorySize) * 100, 1)

            $cpuUsage = (Get-Counter '\Processor(_Total)\% Processor Time' -ErrorAction SilentlyContinue).CounterSamples.CookedValue
            $cpuRounded = [math]::Round($cpuUsage, 1)

            Write-Host "System Resources:" -ForegroundColor White
            Write-Host "  CPU: ${cpuRounded}%" -ForegroundColor Gray
            Write-Host "  Memory: ${usedMemPercent}% (${freeMemGB}GB free / ${totalMemGB}GB total)" -ForegroundColor Gray

            Write-Host ""
            Write-Host "Next check in 5 minutes..." -ForegroundColor DarkGray
            Write-Host "======================================================" -ForegroundColor DarkGray
            Write-Host ""

            if ($iteration % 72 -eq 0) {
              Write-Host ""
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host "6-HOUR STATUS REPORT" -ForegroundColor Yellow
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host "Runtime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
              Write-Host "BigHits4U: Earning points automatically" -ForegroundColor Green
              Write-Host "RDP: Available via Tailscale" -ForegroundColor Green
              Write-Host "Health: Monitoring and Auto-Restart Active" -ForegroundColor Green
              Write-Host ""
              Write-Host "Check your dashboard: bighits4u.com/dashboard" -ForegroundColor Cyan
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host ""
            }

            Start-Sleep -Seconds $checkInterval

            if ($iteration % 12 -eq 0) {
              Get-ChildItem -Path "$env:TEMP" -Filter "*.tmp" -ErrorAction SilentlyContinue |
                Where-Object { $_.LastWriteTime -lt (Get-Date).AddHours(-2) } |
                Remove-Item -Force -ErrorAction SilentlyContinue
            }
          }

          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "SESSION COMPLETED" -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Total Runtime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
          Write-Host "BigHits4U ran successfully!" -ForegroundColor White
          Write-Host "Check your earned points at: https://bighits4u.com/dashboard" -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

      - name: Cleanup
        if: always()
        run: |
          Write-Host "Performing cleanup..." -ForegroundColor Yellow

          Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue | Stop-Process -Force

          try {
            & "$env:ProgramFiles\Tailscale\tailscale.exe" down 2>$null
            Write-Host "Tailscale disconnected" -ForegroundColor Green
          } catch {
            Write-Host "Tailscale cleanup skipped" -ForegroundColor Yellow
          }

          Write-Host "Cleanup completed" -ForegroundColor Green
