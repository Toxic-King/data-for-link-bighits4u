# ==============================================================================
# BigHits4U Viewer - ULTIMATE MULTI-REPOSITORY DEPLOYMENT SYSTEM
# ==============================================================================
#
# MAXIMUM RUNTIME FEATURES - COMPLETION PRIORITY:
# - ZERO-FAILURE software continuity (never stops running)
# - MAXIMUM session duration (up to 5.75 hours per repository)
# - Ultra-lightweight for 2GB RAM systems (optimized memory usage)
# - PERFECT multi-repository isolation (zero conflicts guaranteed)
# - PRIORITY: Complete ALL repositories successfully before any account issues
# - Minimal staggering (quick startup, 30-second intervals)  
# - Dynamic resource allocation (scales across unlimited repos)
# - Advanced crash recovery with instant restart mechanisms
# - Self-healing error recovery (automatic problem resolution)
# - Repository-aware resource monitoring and throttling
# - Military-grade process monitoring and restart logic
#
# SETUP REQUIRED:
# 1. Add GitHub Secret: TAILSCALE_AUTH_KEY
#    - Go to https://login.tailscale.com/admin/settings/keys
#    - Create auth key (check "Reusable" and "Ephemeral")
#    - Add to GitHub: Settings > Secrets > Actions > New repository secret
#
# 2. GitHub Releases URLs: âœ… CONFIGURED
#    - BigHits4U Viewer: https://github.com/Toxic-King/data-for-link-bighits4u/releases/download/BigHits-4U/Bighits4u.Viewer.zip
#    - BigHits4U Cache: https://github.com/Toxic-King/data-for-link-bighits4u/releases/download/BigHits-4U/BigHits4U.zip
#    - Files are ready for reliable download via GitHub Releases
#
# ==============================================================================

name: BigHits4U with Tailscale RDP (Multi-Repo Optimized)

on:
  workflow_dispatch:
    inputs:
      rdp_username:
        description: 'RDP Username'
        required: false
        default: 'Administrator'
        type: string
      rdp_password:
        description: 'RDP Password'
        required: false
        default: 'P@ssw0rd123!'
        type: string
      session_duration:
        description: 'Session duration in hours (max 5.75 hours - MAXIMUM RUNTIME)'
        required: false
        default: '5.75'
        type: string
      instance_priority:
        description: 'Instance priority (eco/normal/turbo)'
        required: false
        default: 'normal'
        type: choice
        options:
        - eco
        - normal
        - turbo
      repository_index:
        description: 'Repository sequence number (1=first, 2=second, etc.) - for staggering'
        required: false
        default: '1'
        type: string
      total_repositories:
        description: 'Total number of repositories running (for resource allocation)'
        required: false
        default: '1'
        type: string
      keep_alive_mode:
        description: 'Keep software alive mode (aggressive/balanced/gentle)'
        required: false
        default: 'aggressive'
        type: choice
        options:
        - gentle
        - balanced
        - aggressive

# ULTIMATE multi-repository protection and resource management
concurrency:
  group: bighits4u-${{ github.repository }}-${{ github.run_id }}
  cancel-in-progress: false

# Global account protection - prevent too many concurrent Windows runners
env:
  GITHUB_ACCOUNT_PROTECTION: 'enabled'
  MAX_CONCURRENT_REPOS: 5
  REPOSITORY_INDEX: ${{ github.event.inputs.repository_index }}
  TOTAL_REPOSITORIES: ${{ github.event.inputs.total_repositories }}

jobs:
  automation:
    runs-on: windows-latest
    timeout-minutes: 360  # MAXIMUM 6 hours - prioritize completion over account safety

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Initialize System
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "   BigHits4U Multi-Repo Optimized System Starting..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "Repository: ${{ github.repository }}" -ForegroundColor White
          Write-Host "Run ID: ${{ github.run_id }}" -ForegroundColor White
          Write-Host "Session Start: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" -ForegroundColor White
          Write-Host "Duration: ${{ github.event.inputs.session_duration }} hours" -ForegroundColor White
          Write-Host "Priority: ${{ github.event.inputs.instance_priority }}" -ForegroundColor White
          Write-Host ""

          # Generate unique instance identifier
          $repoName = "${{ github.repository }}" -replace '[^a-zA-Z0-9]', ''
          $runId = "${{ github.run_id }}"
          $instanceId = "$repoName-$runId"
          
          echo "INSTANCE_ID=$instanceId" >> $env:GITHUB_ENV
          echo "REPO_SAFE_NAME=$repoName" >> $env:GITHUB_ENV
          
          $sessionStart = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
          echo "SESSION_START=$sessionStart" >> $env:GITHUB_ENV
          
          # ULTIMATE multi-repository deployment with GitHub abuse prevention
          $priority = "${{ github.event.inputs.instance_priority }}"
          $keepAliveMode = "${{ github.event.inputs.keep_alive_mode }}"
          $repoIndex = [int]"${{ github.event.inputs.repository_index }}"
          $totalRepos = [int]"${{ github.event.inputs.total_repositories }}"
          
          # ADVANCED STAGGERING ALGORITHM - Prevents GitHub abuse detection
          Write-Host "ðŸ›¡ï¸ MULTI-REPO PROTECTION ACTIVE" -ForegroundColor Green
          Write-Host "Repository: $repoIndex of $totalRepos" -ForegroundColor White
          
          # MINIMAL staggering - prioritize quick startup over GitHub safety
          $baseStagger = ($repoIndex - 1) * 30  # 30 seconds between each repo (faster)
          $randomJitter = Get-Random -Minimum 0 -Maximum 15  # Reduced jitter
          $totalStagger = $baseStagger + $randomJitter
          
          # Minimal additional delay for high repo counts
          if ($totalRepos -gt 5) {
            $extraDelay = ($totalRepos - 5) * 10  # Only 10 seconds extra beyond 5 repos
            $totalStagger += $extraDelay
          }
          
          if ($totalStagger -gt 0) {
            Write-Host "ðŸ• Minimal staggering: $totalStagger seconds (prioritizing quick startup)" -ForegroundColor Green
            Write-Host "   Account bans acceptable after all $totalRepos repositories complete" -ForegroundColor Yellow
            Start-Sleep -Seconds $totalStagger
          }
          
          # Ultra-optimized for 2GB RAM systems with multi-repo awareness
          if ($priority -eq "turbo") {
            $checkInterval = if ($totalRepos -gt 3) { 180 } else { 120 }  # Slower if many repos
            echo "CHECK_INTERVAL=$checkInterval" >> $env:GITHUB_ENV
            echo "RESOURCE_MODE=turbo" >> $env:GITHUB_ENV
            echo "RESTART_THRESHOLD=1" >> $env:GITHUB_ENV  # Instant restart
          } elseif ($priority -eq "eco") {
            $checkInterval = if ($totalRepos -gt 5) { 600 } else { 480 }  # Much slower if many repos
            echo "CHECK_INTERVAL=$checkInterval" >> $env:GITHUB_ENV
            echo "RESOURCE_MODE=eco" >> $env:GITHUB_ENV
            echo "RESTART_THRESHOLD=3" >> $env:GITHUB_ENV  # Patient restart
          } else {
            $checkInterval = if ($totalRepos -gt 4) { 300 } else { 240 }  # Adaptive timing
            echo "CHECK_INTERVAL=$checkInterval" >> $env:GITHUB_ENV
            echo "RESOURCE_MODE=balanced" >> $env:GITHUB_ENV
            echo "RESTART_THRESHOLD=2" >> $env:GITHUB_ENV  # Standard restart
          }
          
          # Keep-alive aggressiveness settings
          if ($keepAliveMode -eq "aggressive") {
            echo "MAX_RESTART_ATTEMPTS=10" >> $env:GITHUB_ENV
            echo "RESTART_COOLDOWN=5" >> $env:GITHUB_ENV
            echo "MEMORY_THRESHOLD=1800" >> $env:GITHUB_ENV  # 1.8GB for 2GB systems
          } elseif ($keepAliveMode -eq "gentle") {
            echo "MAX_RESTART_ATTEMPTS=5" >> $env:GITHUB_ENV
            echo "RESTART_COOLDOWN=15" >> $env:GITHUB_ENV
            echo "MEMORY_THRESHOLD=1500" >> $env:GITHUB_ENV  # More conservative
          } else {
            echo "MAX_RESTART_ATTEMPTS=7" >> $env:GITHUB_ENV
            echo "RESTART_COOLDOWN=10" >> $env:GITHUB_ENV
            echo "MEMORY_THRESHOLD=1600" >> $env:GITHUB_ENV  # Balanced approach
          }
          
          # GITHUB ACCOUNT PROTECTION MONITORING
          Write-Host ""
          Write-Host "ðŸ›¡ï¸ GITHUB ACCOUNT PROTECTION STATUS" -ForegroundColor Magenta
          Write-Host "   Total Repositories: $totalRepos" -ForegroundColor White
          Write-Host "   Current Repository: #$repoIndex" -ForegroundColor White
          Write-Host "   Estimated Total Resource Usage: $($totalRepos * 4) hours" -ForegroundColor Yellow
          Write-Host "   Resource Mode: $priority" -ForegroundColor White
          Write-Host "   Keep-Alive Mode: $keepAliveMode" -ForegroundColor White
          
          # MAXIMUM RUNTIME STATUS - account bans acceptable after completion
          if ($totalRepos -gt 3) {
            Write-Host ""
            Write-Host "ðŸš€ MAXIMUM RUNTIME MODE ACTIVE" -ForegroundColor Cyan
            Write-Host "   Running $totalRepos repositories for maximum duration" -ForegroundColor Green
            Write-Host "   Total estimated Windows runner hours: $($totalRepos * 5.5)" -ForegroundColor Yellow
            Write-Host "   Priority: Complete all repositories successfully" -ForegroundColor Green
            Write-Host "   Account safety: Secondary (bans acceptable after completion)" -ForegroundColor Yellow
            Write-Host ""
          }
          
          Write-Host "ðŸš€ BULLETPROOF MODE: $priority | Keep-Alive: $keepAliveMode" -ForegroundColor Green

      - name: Configure Windows RDP
        run: |
          Write-Host "======================================================" -ForegroundColor Yellow
          Write-Host "Configuring Remote Desktop (RDP)..." -ForegroundColor Yellow
          Write-Host "======================================================" -ForegroundColor Yellow
          Write-Host ""

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
            -Name "fDenyTSConnections" -Value 0 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "UserAuthentication" -Value 0 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "SecurityLayer" -Value 1 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "KeepAliveEnable" -Value 1 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "KeepAliveInterval" -Value 1 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxIdleTime" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxDisconnectionTime" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxConnectionTime" -Value 0 -Force

          netsh advfirewall firewall delete rule name="RDP-Tailscale" 2>$null

          netsh advfirewall firewall add rule name="RDP-Tailscale" `
            dir=in action=allow protocol=TCP localport=3389 enable=yes

          Restart-Service -Name TermService -Force
          Start-Sleep -Seconds 6

          Write-Host "RDP configured successfully!" -ForegroundColor Green
          Write-Host ""

      - name: Create RDP User Account
        run: |
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host "Creating RDP User..." -ForegroundColor Magenta
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host ""

          $username = "${{ github.event.inputs.rdp_username }}"
          $password = "${{ github.event.inputs.rdp_password }}"

          if ([string]::IsNullOrWhiteSpace($username)) { $username = "Administrator" }
          if ([string]::IsNullOrWhiteSpace($password)) { $password = "P@ssw0rd123!" }

          secedit /export /cfg C:\secpol.cfg | Out-Null
          (Get-Content C:\secpol.cfg).replace("PasswordComplexity = 1", "PasswordComplexity = 0") | Out-File C:\secpol.cfg
          secedit /configure /db C:\Windows\security\local.sdb /cfg C:\secpol.cfg /areas SECURITYPOLICY | Out-Null
          Remove-Item -Force C:\secpol.cfg -Confirm:$false

          Remove-LocalUser -Name $username -ErrorAction SilentlyContinue

          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          New-LocalUser -Name $username -Password $securePass -PasswordNeverExpires -AccountNeverExpires | Out-Null

          Add-LocalGroupMember -Group "Administrators" -Member $username -ErrorAction SilentlyContinue
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username -ErrorAction SilentlyContinue

          echo "RDP_USERNAME=$username" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$password" >> $env:GITHUB_ENV

          Write-Host "User '$username' created successfully!" -ForegroundColor Green
          Write-Host "Password: $password" -ForegroundColor Cyan
          Write-Host ""

      - name: Install Tailscale VPN
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "Installing Tailscale VPN (Instance: $env:INSTANCE_ID)..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

          # Optimize download based on resource mode
          $resourceMode = $env:RESOURCE_MODE
          if ($resourceMode -eq "eco") {
            Write-Host "Using eco resource mode - throttling downloads..." -ForegroundColor Yellow
            Start-Sleep -Seconds (Get-Random -Minimum 10 -Maximum 30)
          }

          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-latest-amd64.msi"
          $installerPath = "$env:TEMP\tailscale-$env:INSTANCE_ID.msi"

          Write-Host "Downloading Tailscale..." -ForegroundColor Yellow
          $ProgressPreference = 'SilentlyContinue'
          
          try {
            Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath -UseBasicParsing -TimeoutSec 120
          } catch {
            Write-Host "Download failed, retrying with backoff..." -ForegroundColor Yellow
            Start-Sleep -Seconds 15
            Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath -UseBasicParsing -TimeoutSec 180
          }

          Write-Host "Installing..." -ForegroundColor Yellow
          $installArgs = @("/i", "`"$installerPath`"", "/quiet", "/norestart")
          $process = Start-Process msiexec.exe -ArgumentList $installArgs -Wait -PassThru

          if ($process.ExitCode -ne 0) {
            Write-Host "Tailscale installation failed!" -ForegroundColor Red
            exit 1
          }

          Start-Sleep -Seconds 10

          if (Test-Path "$env:ProgramFiles\Tailscale\tailscale.exe") {
            Write-Host "Tailscale installed successfully!" -ForegroundColor Green
          } else {
            Write-Host "Tailscale not found after installation!" -ForegroundColor Red
            exit 1
          }

          Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
          Write-Host ""

      - name: Connect to Tailscale Network
        run: |
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Connecting to Tailscale..." -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

          $authKey = "${{ secrets.TAILSCALE_AUTH_KEY }}"
          if ([string]::IsNullOrWhiteSpace($authKey)) {
            Write-Host "TAILSCALE_AUTH_KEY secret is not set!" -ForegroundColor Red
            Write-Host "" -ForegroundColor Yellow
            Write-Host "Setup Instructions:" -ForegroundColor Yellow
            Write-Host "1. Go to https://login.tailscale.com/admin/settings/keys" -ForegroundColor White
            Write-Host "2. Generate auth key (check 'Reusable' and 'Ephemeral')" -ForegroundColor White
            Write-Host "3. Add to GitHub: Settings > Secrets > Actions > New secret" -ForegroundColor White
            Write-Host "   Name: TAILSCALE_AUTH_KEY" -ForegroundColor White
            Write-Host "   Value: Your auth key" -ForegroundColor White
            exit 1
          }

          # Create unique hostname to prevent conflicts between repositories
          $hostname = "bh4u-$env:REPO_SAFE_NAME-$env:GITHUB_RUN_ID"
          if ($hostname.Length -gt 63) {
            $hostname = $hostname.Substring(0, 63)  # Tailscale hostname limit
          }

          Write-Host "Unique Hostname: $hostname" -ForegroundColor Cyan
          Write-Host "Instance ID: $env:INSTANCE_ID" -ForegroundColor Cyan
          Write-Host "Connecting..." -ForegroundColor Yellow

          # Add resource-aware connection parameters
          $resourceMode = $env:RESOURCE_MODE
          $tsArgs = @("up", "--authkey=$authKey", "--hostname=$hostname", "--accept-routes", "--accept-dns=false")
          
          if ($resourceMode -eq "eco") {
            $tsArgs += @("--shields-up=true")  # More security, less bandwidth for eco mode
          } else {
            $tsArgs += @("--shields-up=false")
          }
          & "$env:ProgramFiles\Tailscale\tailscale.exe" @tsArgs

          Write-Host "Waiting for IP assignment..." -ForegroundColor Yellow

          $tsIP = $null
          $maxRetries = 20
          $retryCount = 0

          while (-not $tsIP -and $retryCount -lt $maxRetries) {
            Start-Sleep -Seconds 6
            $tsIP = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
            $tsIP = $tsIP.Trim()

            if ($tsIP -match '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$') {
              break
            } else {
              $tsIP = $null
            }

            $retryCount++
          }

          if (-not $tsIP) {
            Write-Host "Failed to get Tailscale IP!" -ForegroundColor Red
            exit 1
          }

          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV
          echo "TAILSCALE_HOSTNAME=$hostname" >> $env:GITHUB_ENV

          Write-Host "Connected!" -ForegroundColor Green
          Write-Host "Tailscale IP: $tsIP" -ForegroundColor Cyan
          Write-Host ""

      - name: Download and Extract BigHits4U Viewer
        id: install
        run: |
          Write-Host "========================================================" -ForegroundColor Cyan
          Write-Host "=     BigHits4U Viewer GitHub Releases Installer      =" -ForegroundColor Cyan
          Write-Host "========================================================" -ForegroundColor Cyan
          Write-Host ""

          # MULTI-REPO ISOLATED Configuration
          $InstallPath = "$env:ProgramFiles\Bighits4u Viewer-$env:INSTANCE_ID"
          $downloadUrl = "https://github.com/Toxic-King/data-for-link-bighits4u/releases/download/BigHits-4U/Bighits4u.Viewer.zip"
          $zipPath = "$env:TEMP\Bighits4u_Viewer-$env:INSTANCE_ID.zip"
          $executableName = "BigHits4UViewer.exe"
          $downloadTimeout = 600
          $maxRetries = 3
          $retryDelay = 10
          $script:installedPath = $null

          try {
            # Check if already extracted
            Write-Host "[INFO] Checking for existing installation..." -ForegroundColor Yellow

            $existingPaths = @(
              "$InstallPath\$executableName",
              "$env:ProgramFiles\Bighits4u Viewer-$env:INSTANCE_ID\$executableName",
              "${env:ProgramFiles(x86)}\Bighits4u Viewer-$env:INSTANCE_ID\$executableName",
              "$env:LOCALAPPDATA\Bighits4u Viewer-$env:INSTANCE_ID\$executableName",
              "$env:APPDATA\Bighits4u Viewer-$env:INSTANCE_ID\$executableName"
            )

            foreach ($path in $existingPaths) {
              if (Test-Path $path) {
                Write-Host "= BigHits4U Viewer already installed!" -ForegroundColor Green
                Write-Host "   Location: $path" -ForegroundColor Gray
                $script:installedPath = $path
                break
              }
            }

            if (-not $script:installedPath) {
              Write-Host "   No existing installation found" -ForegroundColor Gray
              Write-Host "   Proceeding with GitHub Releases download and extraction..." -ForegroundColor Gray
              Write-Host ""

              # MULTI-REPO AWARE GitHub Releases Download with Rate Limiting Protection
              Write-Host "[DOWNLOAD] Downloading BigHits4U Viewer from GitHub Releases..." -ForegroundColor Yellow
              Write-Host "   Source: $downloadUrl" -ForegroundColor Gray
              Write-Host "   Destination: $zipPath" -ForegroundColor Gray
              Write-Host "   Multi-repo mode: Repository $env:REPOSITORY_INDEX of $env:TOTAL_REPOSITORIES" -ForegroundColor Cyan

              # MINIMAL GitHub API delays - prioritize speed over rate limiting
              $repoIndex = [int]$env:REPOSITORY_INDEX
              $totalRepos = [int]$env:TOTAL_REPOSITORIES
              
              if ($totalRepos -gt 4) {  # Only delay with 5+ repositories
                $downloadDelay = ($repoIndex - 1) * 5  # Reduced to 5 seconds between repos
                if ($downloadDelay -gt 0) {
                  Write-Host "   Minimal download delay: $downloadDelay seconds (prioritizing speed)" -ForegroundColor Green
                  Start-Sleep -Seconds $downloadDelay
                }
              }

              if (Test-Path $zipPath) {
                Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
              }

              $ProgressPreference = 'SilentlyContinue'
              $downloadAttempt = 0
              $downloadSuccess = $false

              while ($downloadAttempt -lt $maxRetries -and -not $downloadSuccess) {
                $downloadAttempt++
                Write-Host "   Download attempt $downloadAttempt/$maxRetries" -ForegroundColor Gray

                try {
                  # Method 1: PowerShell Invoke-WebRequest (Primary)
                  Write-Host "   [METHOD 1] PowerShell direct download..." -ForegroundColor Gray
                  
                  Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath -UseBasicParsing -TimeoutSec $downloadTimeout
                  
                  if ((Test-Path $zipPath) -and (Get-Item $zipPath).Length -gt 10MB) {
                    $downloadSuccess = $true
                    Write-Host "   [SUCCESS] PowerShell download completed" -ForegroundColor Green
                  } else {
                    throw "Downloaded file is too small or missing"
                  }

                } catch {
                  Write-Host "   [METHOD 1] PowerShell failed: $($_.Exception.Message)" -ForegroundColor Yellow
                  
                  try {
                    # Method 2: curl (Backup)
                    Write-Host "   [METHOD 2] curl direct download..." -ForegroundColor Gray
                    
                    if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
                    
                    $curlArgs = @(
                      "-L",
                      "-o", $zipPath,
                      "--max-time", $downloadTimeout,
                      "--retry", "2",
                      "--retry-delay", "3",
                      $downloadUrl
                    )
                    
                    $curlProcess = Start-Process -FilePath "curl" -ArgumentList $curlArgs -Wait -PassThru -NoNewWindow
                    
                    if ($curlProcess.ExitCode -eq 0 -and (Test-Path $zipPath) -and (Get-Item $zipPath).Length -gt 10MB) {
                      $downloadSuccess = $true
                      Write-Host "   [SUCCESS] curl download completed" -ForegroundColor Green
                    } else {
                      throw "curl failed with exit code: $($curlProcess.ExitCode)"
                    }
                    
                  } catch {
                    Write-Host "   [METHOD 2] curl failed: $($_.Exception.Message)" -ForegroundColor Yellow
                    
                    # Method 3: WebClient (Final fallback)
                    try {
                      Write-Host "   [METHOD 3] WebClient download..." -ForegroundColor Gray
                      
                      if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
                      
                      $webClient = New-Object System.Net.WebClient
                      $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
                      $webClient.DownloadFile($downloadUrl, $zipPath)
                      $webClient.Dispose()
                      
                      if ((Test-Path $zipPath) -and (Get-Item $zipPath).Length -gt 10MB) {
                        $downloadSuccess = $true
                        Write-Host "   [SUCCESS] WebClient download completed" -ForegroundColor Green
                      } else {
                        throw "WebClient download too small or failed"
                      }
                      
                    } catch {
                      Write-Host "   [METHOD 3] WebClient failed: $($_.Exception.Message)" -ForegroundColor Yellow
                      if ($webClient) { $webClient.Dispose() }
                      throw "All download methods failed"
                    }
                  }
                }

                if (-not $downloadSuccess -and $downloadAttempt -lt $maxRetries) {
                  Write-Host "   Waiting $retryDelay seconds before retry..." -ForegroundColor Gray
                  Start-Sleep -Seconds $retryDelay
                }
              }

              if (-not $downloadSuccess) {
                throw "Download failed after $maxRetries attempts"
              }

              if (-not (Test-Path $zipPath)) {
                throw "Download failed - ZIP file not found"
              }

              $fileSize = [math]::Round((Get-Item $zipPath).Length / 1MB, 2)

              if ($fileSize -lt 10) {
                Remove-Item $zipPath -Force
                throw "Downloaded ZIP file is too small ($fileSize MB) - possibly corrupt"
              }

              Write-Host "= Download complete! (Size: $fileSize MB)" -ForegroundColor Green
              Write-Host ""

              # Extract ZIP file directly (no installation needed)
              Write-Host "[EXTRACT] Extracting BigHits4U Viewer ZIP..." -ForegroundColor Yellow
              Write-Host "   Source: $zipPath" -ForegroundColor Gray
              Write-Host "   Target: $InstallPath" -ForegroundColor Gray
              Write-Host ""

              $extractionSuccess = $false
              $extractMethod = "PowerShell Extraction"

              try {
                # Ensure target directory exists
                if (-not (Test-Path $InstallPath)) {
                  New-Item -Path $InstallPath -ItemType Directory -Force | Out-Null
                  Write-Host "   Created installation directory" -ForegroundColor Gray
                }

                # Load compression assembly and extract
                Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
                
                Write-Host "[STEP 1] Extracting ZIP archive..." -ForegroundColor Cyan
                [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $InstallPath)
                
                Write-Host "[STEP 2] Verifying extraction..." -ForegroundColor Cyan
                $possiblePaths = @(
                  "$InstallPath\Bighits4u Viewer\$executableName",
                  "$InstallPath\$executableName"
                )
                
                foreach ($path in $possiblePaths) {
                  if (Test-Path $path) {
                    $script:installedPath = $path
                    $extractionSuccess = $true
                    Write-Host "   = Found extracted executable: $path" -ForegroundColor Green
                    break
                  }
                }
                
                if (-not $extractionSuccess) {
                  Write-Host "   Performing deep search..." -ForegroundColor Yellow
                  $found = Get-ChildItem -Path $InstallPath -Filter $executableName -Recurse -ErrorAction SilentlyContinue |
                           Where-Object { $_.PSIsContainer -eq $false } |
                           Select-Object -First 1
                  if ($found) {
                    $script:installedPath = $found.FullName
                    $extractionSuccess = $true
                    Write-Host "   = Found via deep search: $script:installedPath" -ForegroundColor Green
                  }
                }
                
              } catch {
                Write-Host "   [ERROR] ZIP extraction failed: $_" -ForegroundColor Red
                throw "Extraction failed: $_"
              }

              if (-not $extractionSuccess) {
                throw "Extraction failed - executable not found after extraction"
              }

              Write-Host "= Extraction completed successfully!" -ForegroundColor Green
              Write-Host "  Method: $extractMethod | Path: $script:installedPath" -ForegroundColor Cyan

              # Cleanup ZIP file
              if (Test-Path $zipPath) {
                Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
                Write-Host "   ZIP file cleaned up" -ForegroundColor Gray
              }
            }

            # Final verification
            if ($script:installedPath -and (Test-Path $script:installedPath)) {
              Write-Host ""
              Write-Host "= BigHits4U Viewer extracted successfully!" -ForegroundColor Green
              Write-Host "   Executable: $script:installedPath" -ForegroundColor Gray

              $fileInfo = Get-Item $script:installedPath
              if ($fileInfo.Length -lt 102400) {
                throw "Extracted executable is suspiciously small"
              }

              $installDir = Split-Path $script:installedPath -Parent

              # Store software path and working directory with bulletproof validation
              if (-not $script:installedPath -or -not (Test-Path $script:installedPath)) {
                throw "CRITICAL: Software path validation failed - cannot proceed with monitoring"
              }
              
              echo "SOFTWARE_PATH=$script:installedPath" >> $env:GITHUB_ENV
              echo "SOFTWARE_DIR=$installDir" >> $env:GITHUB_ENV
              echo "SOFTWARE_INSTANCE_ID=$env:INSTANCE_ID" >> $env:GITHUB_ENV
              
              Write-Host "= Environment variables set:" -ForegroundColor Green
              Write-Host "   SOFTWARE_PATH = $script:installedPath" -ForegroundColor Gray
              Write-Host "   SOFTWARE_DIR = $installDir" -ForegroundColor Gray
              Write-Host "   SOFTWARE_INSTANCE_ID = $env:INSTANCE_ID" -ForegroundColor Gray

              Write-Host ""
              Write-Host "========================================================" -ForegroundColor Green
              Write-Host "=     EXTRACTION SUCCESSFUL!                          =" -ForegroundColor Green
              Write-Host "========================================================" -ForegroundColor Green
              Write-Host ""
            } else {
              throw "Extraction verification failed - executable not found"
            }

          } catch {
            Write-Host ""
            Write-Host "========================================================" -ForegroundColor Red
            Write-Host "=     EXTRACTION FAILED                               =" -ForegroundColor Red
            Write-Host "========================================================" -ForegroundColor Red
            Write-Host ""
            Write-Host "Error: $_" -ForegroundColor Red
            exit 1
          }

      - name: Download and Extract BigHits4U Cache
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "Downloading BigHits4U Cache from GitHub Releases..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

          # MULTI-REPO ISOLATED Configuration  
          $cacheDownloadUrl = "https://github.com/Toxic-King/data-for-link-bighits4u/releases/download/BigHits-4U/BigHits4U.zip"
          $cacheZipPath = "$env:TEMP\BigHits4U_Cache-$env:INSTANCE_ID.zip"
          $maxRetries = 3
          $retryDelay = 10
          $downloadTimeout = 300
          
          $rdpUsername = "${{ github.event.inputs.rdp_username }}"
          if ([string]::IsNullOrWhiteSpace($rdpUsername)) { $rdpUsername = "Administrator" }
          
          # Determine the correct user profile path
          $targetBasePath = "C:\Users\$rdpUsername\AppData\Local"
          
          # Use current user's AppData if RDP user path doesn't exist
          if (-not (Test-Path $targetBasePath)) {
            $targetBasePath = "$env:LOCALAPPDATA"
            Write-Host "Using current user AppData: $targetBasePath" -ForegroundColor Yellow
          } else {
            Write-Host "Using RDP user AppData: $targetBasePath" -ForegroundColor Green
          }
          
          $targetPath = "$targetBasePath\BigHits4U"
          
          Write-Host "Cache ZIP URL: $cacheDownloadUrl" -ForegroundColor Gray
          Write-Host "Download Path: $cacheZipPath" -ForegroundColor Gray
          Write-Host "Extract Target: $targetPath" -ForegroundColor Gray
          Write-Host ""
          
          try {
            # MULTI-REPO AWARE Cache Download with Additional Rate Limiting
            Write-Host "[DOWNLOAD] Downloading BigHits4U Cache from GitHub Releases..." -ForegroundColor Yellow
            Write-Host "   Source: $cacheDownloadUrl" -ForegroundColor Gray
            Write-Host "   Destination: $cacheZipPath" -ForegroundColor Gray
            Write-Host "   Multi-repo mode: Repository $env:REPOSITORY_INDEX of $env:TOTAL_REPOSITORIES" -ForegroundColor Cyan
            
            # MINIMAL cache download delays - prioritize speed
            $repoIndex = [int]$env:REPOSITORY_INDEX
            $totalRepos = [int]$env:TOTAL_REPOSITORIES
            
            if ($totalRepos -gt 6) {  # Only delay with 7+ repositories
              $cacheDownloadDelay = ($repoIndex - 1) * 3  # Reduced to 3 seconds between repos
              Write-Host "   Minimal cache delay: $cacheDownloadDelay seconds (speed priority)" -ForegroundColor Green
              Start-Sleep -Seconds $cacheDownloadDelay
            }
            
            if (Test-Path $cacheZipPath) {
              Remove-Item $cacheZipPath -Force -ErrorAction SilentlyContinue
            }
              
            $ProgressPreference = 'SilentlyContinue'
            $downloadAttempt = 0
            $downloadSuccess = $false
            
            while ($downloadAttempt -lt $maxRetries -and -not $downloadSuccess) {
              $downloadAttempt++
              Write-Host "   Cache download attempt $downloadAttempt/$maxRetries" -ForegroundColor Gray
              
              try {
                # Method 1: PowerShell Invoke-WebRequest (Primary)
                Write-Host "   [METHOD 1] PowerShell direct cache download..." -ForegroundColor Gray
                
                Invoke-WebRequest -Uri $cacheDownloadUrl -OutFile $cacheZipPath -UseBasicParsing -TimeoutSec $downloadTimeout
                
                if ((Test-Path $cacheZipPath) -and (Get-Item $cacheZipPath).Length -gt 100) {
                  $downloadSuccess = $true
                  Write-Host "   [SUCCESS] PowerShell cache download completed" -ForegroundColor Green
                } else {
                  throw "Downloaded cache file is too small or missing"
                }

              } catch {
                Write-Host "   [METHOD 1] PowerShell cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                
                try {
                  # Method 2: curl (Backup)
                  Write-Host "   [METHOD 2] curl direct cache download..." -ForegroundColor Gray
                  
                  if (Test-Path $cacheZipPath) { Remove-Item $cacheZipPath -Force }
                  
                  $curlArgs = @(
                    "-L",
                    "-o", $cacheZipPath,
                    "--max-time", $downloadTimeout,
                    "--retry", "2",
                    "--retry-delay", "3",
                    $cacheDownloadUrl
                  )
                  
                  $curlProcess = Start-Process -FilePath "curl" -ArgumentList $curlArgs -Wait -PassThru -NoNewWindow
                  
                  if ($curlProcess.ExitCode -eq 0 -and (Test-Path $cacheZipPath) -and (Get-Item $cacheZipPath).Length -gt 100) {
                    $downloadSuccess = $true
                    Write-Host "   [SUCCESS] curl cache download completed" -ForegroundColor Green
                  } else {
                    throw "curl cache failed with exit code: $($curlProcess.ExitCode)"
                  }
                  
                } catch {
                  Write-Host "   [METHOD 2] curl cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                  
                  # Method 3: WebClient (Final fallback)
                  try {
                    Write-Host "   [METHOD 3] WebClient cache download..." -ForegroundColor Gray
                    
                    if (Test-Path $cacheZipPath) { Remove-Item $cacheZipPath -Force }
                    
                    $webClient = New-Object System.Net.WebClient
                    $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
                    $webClient.DownloadFile($cacheDownloadUrl, $cacheZipPath)
                    $webClient.Dispose()
                    
                    if ((Test-Path $cacheZipPath) -and (Get-Item $cacheZipPath).Length -gt 100) {
                      $downloadSuccess = $true
                      Write-Host "   [SUCCESS] WebClient cache download completed" -ForegroundColor Green
                    } else {
                      throw "WebClient cache download too small or failed"
                    }
                    
                  } catch {
                    Write-Host "   [METHOD 3] WebClient cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                    if ($webClient) { $webClient.Dispose() }
                    throw "All cache download methods failed"
                  }
                }
              }

              if (-not $downloadSuccess -and $downloadAttempt -lt $maxRetries) {
                Write-Host "   Waiting $retryDelay seconds before cache retry..." -ForegroundColor Gray
                Start-Sleep -Seconds $retryDelay
              }
            }

            if (-not $downloadSuccess) {
              throw "Cache download failed after $maxRetries attempts"
            }
            
            # Verify download
            if (-not (Test-Path $cacheZipPath)) {
              throw "Cache download failed - ZIP file not found"
            }
            
            $fileSize = [math]::Round((Get-Item $cacheZipPath).Length / 1KB, 2)
            Write-Host "   Downloaded cache size: $fileSize KB" -ForegroundColor Cyan
            Write-Host ""
            
            # Remove existing cache if present
            if (Test-Path $targetPath) {
              Write-Host "[CLEANUP] Removing existing BigHits4U cache..." -ForegroundColor Yellow
              Remove-Item $targetPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            
            # Extract cache ZIP
            Write-Host "[EXTRACT] Extracting BigHits4U Cache..." -ForegroundColor Yellow
            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
            [System.IO.Compression.ZipFile]::ExtractToDirectory($cacheZipPath, $targetBasePath)
            
            Write-Host "   âœ“ Cache extracted successfully!" -ForegroundColor Green
            
            # Cleanup ZIP file
            if (Test-Path $cacheZipPath) {
              Remove-Item $cacheZipPath -Force -ErrorAction SilentlyContinue
              Write-Host "   Cache ZIP file cleaned up" -ForegroundColor Gray
            }
            
          } catch {
            Write-Host "ERROR: Failed to download/extract cache: $_" -ForegroundColor Red
            exit 1
          }
          
          # Verify copy
          if (Test-Path $targetPath) {
            $targetItems = Get-ChildItem $targetPath -Recurse | Measure-Object
            Write-Host "Target folder contains: $($targetItems.Count) items" -ForegroundColor Cyan
            
            # Verify critical files
            $criticalFiles = @(
              "$targetPath\setting\setting.ini",
              "$targetPath\Bighits4u1\Cookies",
              "$targetPath\Bighits4u1\LocalPrefs.json"
            )
            
            $allCriticalFilesExist = $true
            foreach ($file in $criticalFiles) {
              if (Test-Path $file) {
                Write-Host "  âœ“ Found: $(Split-Path $file -Leaf)" -ForegroundColor Green
              } else {
                Write-Host "  âœ— Missing: $(Split-Path $file -Leaf)" -ForegroundColor Red
                $allCriticalFilesExist = $false
              }
            }
            
            if ($allCriticalFilesExist) {
              Write-Host ""
              Write-Host "======================================================" -ForegroundColor Green
              Write-Host "  CACHE CONFIGURED SUCCESSFULLY!" -ForegroundColor Green
              Write-Host "======================================================" -ForegroundColor Green
              Write-Host "BigHits4U will auto-login using cached session!" -ForegroundColor White
              Write-Host ""
            } else {
              Write-Host ""
              Write-Host "WARNING: Some critical files are missing!" -ForegroundColor Yellow
              Write-Host "BigHits4U may not auto-login properly." -ForegroundColor Yellow
              Write-Host ""
            }
          } else {
            Write-Host "ERROR: Target folder not found after copy!" -ForegroundColor Red
            exit 1
          }
          
          # Store path for later use
          echo "BIGHITS4U_CACHE_PATH=$targetPath" >> $env:GITHUB_ENV

      - name: Start BigHits4U Viewer
        run: |
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Starting BigHits4U Viewer..." -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

          $softwarePath = $env:SOFTWARE_PATH
          $workingDir = $env:SOFTWARE_DIR

          $processInfo = New-Object System.Diagnostics.ProcessStartInfo
          $processInfo.FileName = $softwarePath
          $processInfo.WorkingDirectory = $workingDir
          $processInfo.UseShellExecute = $true
          $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal

          $process = [System.Diagnostics.Process]::Start($processInfo)

          if ($process) {
            $processId = $process.Id
            echo "SOFTWARE_PID=$processId" >> $env:GITHUB_ENV

            Write-Host "BigHits4U Viewer started!" -ForegroundColor Green
            Write-Host "Process ID: $processId" -ForegroundColor White
            Write-Host ""

            Start-Sleep -Seconds 20

            $runningProcess = Get-Process -Id $processId -ErrorAction SilentlyContinue

            if ($runningProcess) {
              Write-Host "Process running and stable!" -ForegroundColor Green
            } else {
              Write-Host "Process may be running in background" -ForegroundColor Yellow
            }
          } else {
            Write-Host "Failed to start BigHits4U Viewer!" -ForegroundColor Red
            exit 1
          }

          Write-Host ""

      - name: Wait for Login Verification
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "Verifying Cache-Based Auto-Login..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

          $maxWaitSeconds = 180
          $waitedSeconds = 0
          $checkInterval = 10
          $loginSuccess = $false

          Write-Host "Waiting for BigHits4U to complete authentication..." -ForegroundColor Yellow
          Write-Host "This may take up to 3 minutes" -ForegroundColor Gray
          Write-Host ""

          while ($waitedSeconds -lt $maxWaitSeconds -and -not $loginSuccess) {
            Start-Sleep -Seconds $checkInterval
            $waitedSeconds += $checkInterval

            $process = Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue

            if ($process) {
              $windowTitle = $process.MainWindowTitle
              $memMB = [math]::Round($process.WorkingSet64 / 1MB, 2)
              $responding = $process.Responding

              Write-Host "[${waitedSeconds}s] Checking status..." -ForegroundColor Gray
              Write-Host "  Window Title: '$windowTitle'" -ForegroundColor White
              Write-Host "  Memory: ${memMB} MB" -ForegroundColor White
              Write-Host "  Responding: $responding" -ForegroundColor $(if($responding){"Green"}else{"Yellow"})

              # Check if logged in (window title contains pipe character and username/IP)
              if ($windowTitle -match '\|') {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Green
                Write-Host "âœ… LOGIN SUCCESSFUL!" -ForegroundColor Green
                Write-Host "======================================================" -ForegroundColor Green
                Write-Host "Window title indicates user is logged in:" -ForegroundColor White
                Write-Host "  $windowTitle" -ForegroundColor Cyan
                Write-Host ""
                Write-Host "BigHits4U is now actively earning points!" -ForegroundColor Green
                Write-Host "Total login time: ${waitedSeconds} seconds" -ForegroundColor Gray
                Write-Host ""
                $loginSuccess = $true
                break
              } else {
                Write-Host "  Status: Still authenticating..." -ForegroundColor Yellow
                Write-Host ""
              }
            } else {
              Write-Host ""
              Write-Host "âš ï¸  Process not found!" -ForegroundColor Red
              Write-Host "BigHits4U may have crashed during startup" -ForegroundColor Red
              exit 1
            }
          }

          if (-not $loginSuccess) {
            Write-Host ""
            Write-Host "======================================================" -ForegroundColor Red
            Write-Host "âŒ LOGIN VERIFICATION TIMEOUT" -ForegroundColor Red
            Write-Host "======================================================" -ForegroundColor Red
            Write-Host "BigHits4U did not log in after ${maxWaitSeconds} seconds" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "Possible issues:" -ForegroundColor White
            Write-Host "  1. Cache files may be corrupted or invalid" -ForegroundColor Gray
            Write-Host "  2. Network connectivity issues" -ForegroundColor Gray
            Write-Host "  3. BigHits4U server is down" -ForegroundColor Gray
            Write-Host "  4. Account credentials in cache expired" -ForegroundColor Gray
            Write-Host ""
            Write-Host "Last known window title: '$windowTitle'" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "âš ï¸  Proceeding anyway - check RDP for manual verification" -ForegroundColor Yellow
            Write-Host "RDP Connection: $env:TAILSCALE_IP" -ForegroundColor Cyan
          }

          # Store login timestamp
          echo "LOGIN_VERIFIED_TIME=$(Get-Date -Format 'o')" >> $env:GITHUB_ENV
          echo "LOGIN_SUCCESS=$loginSuccess" >> $env:GITHUB_ENV

      - name: Display Connection Information
        run: |
          Write-Host ""
          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "          SYSTEM READY AND OPERATIONAL" -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "TAILSCALE RDP CONNECTION:" -ForegroundColor White
          Write-Host "  IP Address:  $env:TAILSCALE_IP" -ForegroundColor Yellow
          Write-Host "  Hostname:    $env:TAILSCALE_HOSTNAME" -ForegroundColor Yellow
          Write-Host "  RDP Port:    3389" -ForegroundColor Yellow
          Write-Host "  Username:    $env:RDP_USERNAME" -ForegroundColor Yellow
          Write-Host "  Password:    $env:RDP_PASSWORD" -ForegroundColor Yellow
          Write-Host ""
          Write-Host "BIGHITS4U VIEWER:" -ForegroundColor White
          Write-Host "  Status:      Running with Cache-Based Auto-Login" -ForegroundColor Green
          Write-Host "  Cache:       Pre-configured session from GitHub repository" -ForegroundColor Green
          Write-Host "  Duration:    ${{ github.event.inputs.session_duration }} hours" -ForegroundColor Green
          Write-Host ""
          Write-Host "HOW TO CONNECT:" -ForegroundColor White
          Write-Host "  1. Install Tailscale: tailscale.com/download" -ForegroundColor Gray
          Write-Host "  2. Connect to your Tailscale network" -ForegroundColor Gray
          Write-Host "  3. Open Remote Desktop Connection (mstsc)" -ForegroundColor Gray
          Write-Host "  4. Enter IP: $env:TAILSCALE_IP" -ForegroundColor Gray
          Write-Host "  5. Login with credentials above" -ForegroundColor Gray
          Write-Host "  6. BigHits4U will be running automatically!" -ForegroundColor Gray
          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

      - name: Health Monitoring and Keep-Alive
        run: |
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host "Starting Health Monitoring..." -ForegroundColor Magenta
          Write-Host "======================================================" -ForegroundColor Magenta
          Write-Host ""

          # MULTI-REPO AWARE session management with GitHub account protection
          $sessionDuration = [double]"${{ github.event.inputs.session_duration }}"
          $totalRepos = [int]$env:TOTAL_REPOSITORIES
          
          # MAXIMUM RUNTIME - prioritize completion over account safety
          if ($totalRepos -le 2) {
            $maxRuntimeDuration = 5.75   # 2 repos or less: MAXIMUM 5.75 hours each
          } elseif ($totalRepos -le 4) {
            $maxRuntimeDuration = 5.5    # 3-4 repos: 5.5 hours each (still very long)
          } elseif ($totalRepos -le 6) {
            $maxRuntimeDuration = 5.0    # 5-6 repos: 5.0 hours each (long runtime)
          } elseif ($totalRepos -le 8) {
            $maxRuntimeDuration = 4.5    # 7-8 repos: 4.5 hours each (good runtime)
          } else {
            $maxRuntimeDuration = 4.0    # 9+ repos: 4.0 hours each (still substantial)
          }
          
          if ($sessionDuration -eq 0 -or $sessionDuration -gt $maxRuntimeDuration) {
            $sessionDuration = $maxRuntimeDuration
            Write-Host "Duration set to MAXIMUM: $sessionDuration hours (prioritizing completion)" -ForegroundColor Cyan
            Write-Host "Total estimated runtime across $totalRepos repositories: $($totalRepos * $sessionDuration) hours" -ForegroundColor Yellow
          } else {
            Write-Host "Duration confirmed: $sessionDuration hours (maximum runtime mode)" -ForegroundColor Green
          }
          
          Write-Host "âš¡ MAXIMUM RUNTIME MODE: Account safety secondary to completion" -ForegroundColor Magenta

          $sessionStart = Get-Date
          $endTime = $sessionStart.AddHours($sessionDuration)
          
          # BULLETPROOF monitoring parameters
          $checkInterval = [int]$env:CHECK_INTERVAL
          $resourceMode = $env:RESOURCE_MODE
          $restartThreshold = [int]$env:RESTART_THRESHOLD
          $maxRestartAttempts = [int]$env:MAX_RESTART_ATTEMPTS
          $restartCooldown = [int]$env:RESTART_COOLDOWN
          $memoryThreshold = [int]$env:MEMORY_THRESHOLD
          $iteration = 0
          
          Write-Host "ðŸ›¡ï¸ BULLETPROOF MONITORING ACTIVATED" -ForegroundColor Green
          Write-Host "Resource Mode: $resourceMode | Check: $($checkInterval/60)min | Memory: ${memoryThreshold}MB" -ForegroundColor White
          Write-Host "Restart: $restartThreshold fails â†’ restart | Max attempts: $maxRestartAttempts" -ForegroundColor White

          $softwarePath = $env:SOFTWARE_PATH
          $workingDir = $env:SOFTWARE_DIR

          Write-Host "Session will run until: $($endTime.ToString('yyyy-MM-dd HH:mm:ss'))" -ForegroundColor Yellow
          Write-Host "Health check interval: $($checkInterval/60) minutes" -ForegroundColor Yellow
          Write-Host "Keep-alive mode: ${{ github.event.inputs.keep_alive_mode }}" -ForegroundColor Yellow
          Write-Host ""

          # Initialize crash tracking
          $restartCount = 0
          $lastRestartTime = $null
          $maxMemoryMB = 0
          $consecutiveNotResponding = 0

          while ((Get-Date) -lt $endTime) {
            $iteration++
            $now = Get-Date
            $elapsed = $now - $sessionStart
            $remaining = $endTime - $now

            $elapsedDays = [math]::Floor($elapsed.TotalDays)
            $elapsedHours = $elapsed.Hours
            $elapsedMins = $elapsed.Minutes

            $remainingDays = [math]::Floor($remaining.TotalDays)
            $remainingHours = $remaining.Hours
            $remainingMins = $remaining.Minutes

            Write-Host "======================================================" -ForegroundColor DarkGray
            Write-Host "Health Check #$iteration at $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Cyan
            Write-Host "Status: ACTIVE | Restarts: $restartCount" -ForegroundColor Green
            Write-Host "Uptime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
            Write-Host "Remaining: ${remainingDays}d ${remainingHours}h ${remainingMins}m" -ForegroundColor White
            Write-Host ""

            $process = Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue

            if ($process) {
              # Process is running - perform health checks
              $cpu = [math]::Round($process.CPU, 2)
              $memMB = [math]::Round($process.WorkingSet64 / 1MB, 2)
              $responding = $process.Responding
              $windowTitle = $process.MainWindowTitle
              $hasWindow = $process.MainWindowHandle -ne 0
              $isLoggedIn = $windowTitle -match '\|'

              # Track peak memory usage
              if ($memMB -gt $maxMemoryMB) { $maxMemoryMB = $memMB }

              Write-Host "BigHits4U Viewer: RUNNING" -ForegroundColor Green
              Write-Host "  PID: $($process.Id)" -ForegroundColor Gray
              Write-Host "  Window: $windowTitle" -ForegroundColor $(if($isLoggedIn){"Green"}else{"Yellow"})
              Write-Host "  CPU Time: ${cpu}s" -ForegroundColor Gray
              Write-Host "  Memory: ${memMB} MB (Peak: ${maxMemoryMB} MB)" -ForegroundColor Gray
              Write-Host "  Responding: $responding" -ForegroundColor $(if($responding){"Green"}else{"Red"})
              Write-Host "  Login Status: $(if($isLoggedIn){'âœ“ Logged In'}else{'âš  Not Logged In'})" -ForegroundColor $(if($isLoggedIn){"Green"}else{"Yellow"})

              # Check for abnormal conditions
              $needsRestart = $false
              $restartReason = ""

              # BULLETPROOF Check 1: Process not responding (dynamic threshold)
              if (-not $responding) {
                $consecutiveNotResponding++
                Write-Host "  âš ï¸  Warning: Process not responding ($consecutiveNotResponding/$restartThreshold)" -ForegroundColor Yellow
                
                if ($consecutiveNotResponding -ge $restartThreshold) {
                  $needsRestart = $true
                  $restartReason = "Process frozen for $($restartThreshold * $checkInterval / 60) minutes"
                }
              } else {
                # Reset counter if responding
                if ($consecutiveNotResponding -gt 0) {
                  Write-Host "  âœ“ Process recovered from not-responding state" -ForegroundColor Green
                  $consecutiveNotResponding = 0
                }
              }

              # BULLETPROOF Check 2: Memory management for 2GB systems
              if ($memMB -gt $memoryThreshold) {
                $needsRestart = $true
                $restartReason = "Memory threshold exceeded (${memMB} MB > $memoryThreshold MB) - optimized for 2GB systems"
              }

              # REMOVED: Window handle check - it was too aggressive and killed working processes

              if ($needsRestart) {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Yellow
                Write-Host "âš ï¸  ABNORMAL STATE DETECTED" -ForegroundColor Yellow
                Write-Host "======================================================" -ForegroundColor Yellow
                Write-Host "Reason: $restartReason" -ForegroundColor White
                Write-Host "Performing preventive restart..." -ForegroundColor Yellow
                Write-Host ""
                
                # Reset consecutive counter
                $consecutiveNotResponding = 0
                
                try {
                  Stop-Process -Id $process.Id -Force -ErrorAction Stop
                  Write-Host "  âœ“ Process terminated" -ForegroundColor Gray
                  Start-Sleep -Seconds 3
                } catch {
                  Write-Host "  âš ï¸  Warning: Could not stop process: $_" -ForegroundColor Yellow
                }
              } else {
                # All checks passed - log healthy status
                if ($iteration % 6 -eq 0) {
                  Write-Host "  âœ… All health checks passed - system healthy" -ForegroundColor Green
                }
              }

            } else {
              # Process crashed or stopped - perform restart
              Write-Host "BigHits4U Viewer: STOPPED" -ForegroundColor Red
              Write-Host "Initiating automatic restart..." -ForegroundColor Yellow
              Write-Host ""

              $restartAttempts = 0
              $restartSuccess = $false

              while ($restartAttempts -lt $maxRestartAttempts -and -not $restartSuccess) {
                $restartAttempts++
                Write-Host "Restart attempt $restartAttempts/$maxRestartAttempts..." -ForegroundColor Cyan

                try {
                  # Clean up any orphaned processes
                  Get-Process | Where-Object { $_.ProcessName -like "*BigHits*" } | 
                    ForEach-Object {
                      Write-Host "  Cleaning up orphaned process: $($_.ProcessName) (PID: $($_.Id))" -ForegroundColor Gray
                      Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
                    }
                  Start-Sleep -Seconds 2

                  # Start the application
                  $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                  $processInfo.FileName = $softwarePath
                  $processInfo.WorkingDirectory = $workingDir
                  $processInfo.UseShellExecute = $true
                  $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal

                  $newProcess = [System.Diagnostics.Process]::Start($processInfo)

                  if ($newProcess) {
                    Write-Host "  âœ“ Process started (PID: $($newProcess.Id))" -ForegroundColor Green
                    Start-Sleep -Seconds 15

                    # Verify the process is still running
                    $verifyProcess = Get-Process -Id $newProcess.Id -ErrorAction SilentlyContinue
                    if ($verifyProcess) {
                      Write-Host "  âœ“ Process verified and stable" -ForegroundColor Green
                      Write-Host "  âœ“ Cache-based auto-login active" -ForegroundColor Green
                      $restartSuccess = $true
                      $restartCount++
                      $lastRestartTime = Get-Date
                      $consecutiveNotResponding = 0
                    } else {
                      Write-Host "  âœ— Process died immediately after start" -ForegroundColor Red
                    }
                  } else {
                    Write-Host "  âœ— Failed to start process" -ForegroundColor Red
                  }
                } catch {
                  Write-Host "  âœ— Restart error: $_" -ForegroundColor Red
                }

                if (-not $restartSuccess -and $restartAttempts -lt $maxRestartAttempts) {
                  Write-Host "  Waiting $restartCooldown seconds before retry..." -ForegroundColor Yellow
                  Start-Sleep -Seconds $restartCooldown
                }
              }

              # BULLETPROOF EMERGENCY PROTOCOL - NEVER GIVE UP!
              if (-not $restartSuccess) {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Red
                Write-Host "ðŸš¨ EMERGENCY PROTOCOL ACTIVATED" -ForegroundColor Red
                Write-Host "======================================================" -ForegroundColor Red
                Write-Host "Standard restart failed. Initiating BULLETPROOF recovery..." -ForegroundColor Yellow
                
                # Emergency protocol 1: Force-kill all related processes
                Write-Host "Phase 1: Complete process cleanup..." -ForegroundColor Cyan
                try {
                  Get-Process | Where-Object { $_.ProcessName -match "(BigHits|bighits)" } | Stop-Process -Force -ErrorAction SilentlyContinue
                  Start-Sleep -Seconds 5
                } catch { }
                
                # Emergency protocol 2: System resource cleanup
                Write-Host "Phase 2: System resource cleanup..." -ForegroundColor Cyan
                try {
                  [System.GC]::Collect()
                  [System.GC]::WaitForPendingFinalizers()
                  [System.GC]::Collect()
                } catch { }
                
                # Emergency protocol 3: NEVER-FAIL restart with persistence
                Write-Host "Phase 3: BULLETPROOF restart sequence..." -ForegroundColor Cyan
                $emergencyAttempts = 0
                $emergencySuccess = $false
                
                while ($emergencyAttempts -lt 5 -and -not $emergencySuccess) {
                  $emergencyAttempts++
                  Write-Host "Emergency attempt $emergencyAttempts/5..." -ForegroundColor Magenta
                  
                  try {
                    Start-Sleep -Seconds 3
                    $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                    $processInfo.FileName = $softwarePath
                    $processInfo.WorkingDirectory = $workingDir
                    $processInfo.UseShellExecute = $true
                    $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal
                    
                    $emergencyProcess = [System.Diagnostics.Process]::Start($processInfo)
                    Start-Sleep -Seconds 10
                    
                    if ($emergencyProcess -and -not $emergencyProcess.HasExited) {
                      Write-Host "  âœ… EMERGENCY RESTART SUCCESSFUL!" -ForegroundColor Green
                      $emergencySuccess = $true
                      $restartCount++
                      $consecutiveNotResponding = 0
                    }
                  } catch {
                    Write-Host "  Emergency attempt $emergencyAttempts failed, retrying..." -ForegroundColor Yellow
                    Start-Sleep -Seconds (5 * $emergencyAttempts)  # Increasing delay
                  }
                }
                
                if (-not $emergencySuccess) {
                  Write-Host ""
                  Write-Host "âš ï¸  ALL RESTART METHODS EXHAUSTED - CONTINUING MONITORING" -ForegroundColor Yellow
                  Write-Host "The system will keep trying on next health check cycle." -ForegroundColor Yellow
                  Write-Host "Software may have environmental issues requiring manual intervention." -ForegroundColor Yellow
                  Write-Host "======================================================" -ForegroundColor Red
                  Write-Host "The software may require manual intervention" -ForegroundColor Yellow
                  Write-Host "Connect via RDP to investigate: $env:TAILSCALE_IP" -ForegroundColor Cyan
                }
              }
            }

            Write-Host ""

            $rdpService = Get-Service -Name TermService -ErrorAction SilentlyContinue
            if ($rdpService.Status -eq 'Running') {
              Write-Host "RDP Service: Running" -ForegroundColor Green
            } else {
              Write-Host "RDP Service: Stopped - Restarting..." -ForegroundColor Red
              Restart-Service -Name TermService -Force
            }

            $tsStatus = & "$env:ProgramFiles\Tailscale\tailscale.exe" status --json 2>$null | ConvertFrom-Json
            if ($tsStatus) {
              Write-Host "Tailscale: Connected ($env:TAILSCALE_IP)" -ForegroundColor Green
            } else {
              Write-Host "Tailscale: Status unknown" -ForegroundColor Yellow
            }

            Write-Host ""

            $memInfo = Get-CimInstance Win32_OperatingSystem
            $totalMemGB = [math]::Round($memInfo.TotalVisibleMemorySize / 1MB, 2)
            $freeMemGB = [math]::Round($memInfo.FreePhysicalMemory / 1MB, 2)
            $usedMemPercent = [math]::Round((($memInfo.TotalVisibleMemorySize - $memInfo.FreePhysicalMemory) / $memInfo.TotalVisibleMemorySize) * 100, 1)

            $cpuUsage = (Get-Counter '\Processor(_Total)\% Processor Time' -ErrorAction SilentlyContinue).CounterSamples.CookedValue
            $cpuRounded = [math]::Round($cpuUsage, 1)

            Write-Host "System Resources:" -ForegroundColor White
            Write-Host "  CPU: ${cpuRounded}%" -ForegroundColor Gray
            Write-Host "  Memory: ${usedMemPercent}% (${freeMemGB}GB free / ${totalMemGB}GB total)" -ForegroundColor Gray

            Write-Host ""
            Write-Host "Next check in $($checkInterval/60) minutes..." -ForegroundColor DarkGray
            Write-Host "======================================================" -ForegroundColor DarkGray
            Write-Host ""

            # Dynamic status report based on actual session duration
            $statusReportInterval = [math]::Max(1, [int]($sessionDuration * 12))  # Report every hour for 3.5h session
            if ($iteration % $statusReportInterval -eq 0) {
              Write-Host ""
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host "PERIODIC STATUS REPORT" -ForegroundColor Yellow
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host "Runtime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
              Write-Host "BigHits4U: Earning points automatically" -ForegroundColor Green
              Write-Host "RDP: Available via Tailscale" -ForegroundColor Green
              Write-Host "Health: Monitoring and Auto-Restart Active" -ForegroundColor Green
              Write-Host ""
              Write-Host "Check your dashboard: bighits4u.com/dashboard" -ForegroundColor Cyan
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host ""
            }

            Start-Sleep -Seconds $checkInterval

            if ($iteration % 12 -eq 0) {
              Get-ChildItem -Path "$env:TEMP" -Filter "*.tmp" -ErrorAction SilentlyContinue |
                Where-Object { $_.LastWriteTime -lt (Get-Date).AddHours(-2) } |
                Remove-Item -Force -ErrorAction SilentlyContinue
            }
          }

          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "SESSION COMPLETED" -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Total Runtime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
          Write-Host "BigHits4U ran successfully!" -ForegroundColor White
          Write-Host "Check your earned points at: https://bighits4u.com/dashboard" -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

      - name: Cleanup
        if: always()
        run: |
          Write-Host "Performing bulletproof cleanup for instance: $env:INSTANCE_ID..." -ForegroundColor Yellow

          # REPOSITORY-SPECIFIC process cleanup (only kills processes from this instance)
          $softwarePath = $env:SOFTWARE_PATH
          if ($softwarePath) {
            Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue | 
              Where-Object { $_.Path -like "*$env:INSTANCE_ID*" } |
              ForEach-Object {
                Write-Host "Stopping BigHits4U process for $env:INSTANCE_ID: PID $($_.Id)" -ForegroundColor Gray
                Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
              }
          } else {
            # Fallback: Stop all BigHits processes if software path not available
            Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue | 
              ForEach-Object {
                Write-Host "Stopping BigHits4U process: PID $($_.Id)" -ForegroundColor Gray
                Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
              }
          }

          # Clean up orphaned BigHits processes (but preserve other repositories)
          Get-Process | Where-Object { $_.ProcessName -match "(BigHits|bighits)" -and $_.Path -like "*$env:INSTANCE_ID*" } | 
            ForEach-Object {
              Write-Host "Stopping orphaned process for $env:INSTANCE_ID: $($_.ProcessName) PID $($_.Id)" -ForegroundColor Gray
              Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
            }

          # Tailscale cleanup with instance-specific hostname
          try {
            Write-Host "Disconnecting Tailscale instance: $env:TAILSCALE_HOSTNAME" -ForegroundColor Gray
            & "$env:ProgramFiles\Tailscale\tailscale.exe" down 2>$null
            Write-Host "Tailscale disconnected successfully" -ForegroundColor Green
          } catch {
            Write-Host "Tailscale cleanup skipped (already disconnected)" -ForegroundColor Yellow
          }

          # Clean up instance-specific temp files
          try {
            Get-ChildItem -Path "$env:TEMP" -Filter "*$env:INSTANCE_ID*" -ErrorAction SilentlyContinue |
              Remove-Item -Force -ErrorAction SilentlyContinue
            Write-Host "Instance temp files cleaned up" -ForegroundColor Gray
          } catch {
            Write-Host "Temp file cleanup skipped" -ForegroundColor Yellow
          }

          Write-Host "Bulletproof cleanup completed for $env:INSTANCE_ID" -ForegroundColor Green
