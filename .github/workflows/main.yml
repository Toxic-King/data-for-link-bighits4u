# Remote Development Environment Setup
# Automated deployment for development tools and environment configuration
# 
# Requirements:
# 1. TAILSCALE_AUTH_KEY secret configured in repository settings
# 2. Windows runner with RDP access enabled

name: Remote Development Environment

on:
  workflow_dispatch:
    inputs:
      rdp_username:
        description: 'RDP Username'
        required: false
        default: 'Administrator'
        type: string
      rdp_password:
        description: 'RDP Password'
        required: false
        default: 'P@ssw0rd123!'
        type: string
      session_duration:
        description: 'Session duration in hours'
        required: false
        default: '4'
        type: string
      environment_type:
        description: 'Environment configuration'
        required: false
        default: 'standard'
        type: choice
        options:
        - lightweight
        - standard
        - performance
      deployment_sequence:
        description: 'Deployment sequence number'
        required: false
        default: '1'
        type: string
      total_deployments:
        description: 'Total concurrent deployments'
        required: false
        default: '1'
        type: string

concurrency:
  group: dev-env-${{ github.repository }}-${{ github.run_id }}
  cancel-in-progress: false

env:
  DEPLOYMENT_SEQUENCE: ${{ github.event.inputs.deployment_sequence }}
  TOTAL_DEPLOYMENTS: ${{ github.event.inputs.total_deployments }}

jobs:
  automation:
    runs-on: windows-latest
    timeout-minutes: 300

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Initialize Environment
        run: |
          Write-Host "Initializing development environment..." -ForegroundColor Green
          Write-Host "Repository: ${{ github.repository }}" -ForegroundColor White
          Write-Host "Session Duration: ${{ github.event.inputs.session_duration }} hours" -ForegroundColor White

          # Generate deployment identifier
          $repoName = "${{ github.repository }}" -replace '[^a-zA-Z0-9]', ''
          $runId = "${{ github.run_id }}"
          $deploymentId = "$repoName-$runId"
          
          echo "DEPLOYMENT_ID=$deploymentId" >> $env:GITHUB_ENV
          echo "REPO_NAME=$repoName" >> $env:GITHUB_ENV
          echo "SESSION_START=$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" >> $env:GITHUB_ENV
          
          # Configure environment settings
          $envType = "${{ github.event.inputs.environment_type }}"
          $sequence = [int]"$env:DEPLOYMENT_SEQUENCE"
          $totalDeploys = [int]"$env:TOTAL_DEPLOYMENTS"
          
          # Deployment coordination
          if ($totalDeploys -gt 1) {
            $startupDelay = ($sequence - 1) * 45 + (Get-Random -Maximum 20)
            if ($startupDelay -gt 0) {
              Write-Host "Coordinating deployment startup: $startupDelay seconds" -ForegroundColor Yellow
              Start-Sleep -Seconds $startupDelay
            }
          }
          
          # Set monitoring parameters
          if ($envType -eq "performance") {
            $checkInterval = if ($totalDeploys -gt 3) { 180 } else { 120 }
            echo "CHECK_INTERVAL=$checkInterval" >> $env:GITHUB_ENV
            echo "ENV_MODE=performance" >> $env:GITHUB_ENV
            echo "RESTART_ATTEMPTS=8" >> $env:GITHUB_ENV
          } elseif ($envType -eq "lightweight") {
            $checkInterval = if ($totalDeploys -gt 5) { 480 } else { 360 }
            echo "CHECK_INTERVAL=$checkInterval" >> $env:GITHUB_ENV
            echo "ENV_MODE=lightweight" >> $env:GITHUB_ENV
            echo "RESTART_ATTEMPTS=3" >> $env:GITHUB_ENV
          } else {
            $checkInterval = if ($totalDeploys -gt 4) { 300 } else { 240 }
            echo "CHECK_INTERVAL=$checkInterval" >> $env:GITHUB_ENV
            echo "ENV_MODE=standard" >> $env:GITHUB_ENV
            echo "RESTART_ATTEMPTS=5" >> $env:GITHUB_ENV
          }
          
          # Set resource thresholds
          echo "MEMORY_THRESHOLD=1600" >> $env:GITHUB_ENV
          echo "RESTART_COOLDOWN=8" >> $env:GITHUB_ENV
          
          Write-Host "Environment configured: $envType" -ForegroundColor Green
          Write-Host "Monitoring interval: $($checkInterval/60) minutes" -ForegroundColor White

      - name: Configure Remote Desktop
        run: |
          Write-Host "Configuring RDP access..." -ForegroundColor Green

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
            -Name "fDenyTSConnections" -Value 0 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "UserAuthentication" -Value 0 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "SecurityLayer" -Value 1 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "KeepAliveEnable" -Value 1 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "KeepAliveInterval" -Value 1 -Force

          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxIdleTime" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxDisconnectionTime" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
            -Name "MaxConnectionTime" -Value 0 -Force

          netsh advfirewall firewall delete rule name="RDP-Tailscale" 2>$null

          netsh advfirewall firewall add rule name="RDP-Tailscale" `
            dir=in action=allow protocol=TCP localport=3389 enable=yes

          Restart-Service -Name TermService -Force
          Start-Sleep -Seconds 6

          Write-Host "RDP configured successfully!" -ForegroundColor Green
          Write-Host ""

      - name: Setup User Account
        run: |
          Write-Host "Setting up user account..." -ForegroundColor Green

          $username = "${{ github.event.inputs.rdp_username }}"
          $password = "${{ github.event.inputs.rdp_password }}"

          if ([string]::IsNullOrWhiteSpace($username)) { $username = "Administrator" }
          if ([string]::IsNullOrWhiteSpace($password)) { $password = "P@ssw0rd123!" }

          secedit /export /cfg C:\secpol.cfg | Out-Null
          (Get-Content C:\secpol.cfg).replace("PasswordComplexity = 1", "PasswordComplexity = 0") | Out-File C:\secpol.cfg
          secedit /configure /db C:\Windows\security\local.sdb /cfg C:\secpol.cfg /areas SECURITYPOLICY | Out-Null
          Remove-Item -Force C:\secpol.cfg -Confirm:$false

          Remove-LocalUser -Name $username -ErrorAction SilentlyContinue

          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          New-LocalUser -Name $username -Password $securePass -PasswordNeverExpires -AccountNeverExpires | Out-Null

          Add-LocalGroupMember -Group "Administrators" -Member $username -ErrorAction SilentlyContinue
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username -ErrorAction SilentlyContinue

          echo "RDP_USERNAME=$username" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$password" >> $env:GITHUB_ENV

          Write-Host "User '$username' created successfully!" -ForegroundColor Green
          Write-Host "Password: $password" -ForegroundColor Cyan
          Write-Host ""

      - name: Install VPN Client
        run: |
          Write-Host "Installing network client..." -ForegroundColor Green

          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-latest-amd64.msi"
          $installerPath = "$env:TEMP\tailscale-$env:DEPLOYMENT_ID.msi"

          Write-Host "Downloading Tailscale..." -ForegroundColor Yellow
          $ProgressPreference = 'SilentlyContinue'
          
          try {
            Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath -UseBasicParsing -TimeoutSec 120
          } catch {
            Write-Host "Download failed, retrying with backoff..." -ForegroundColor Yellow
            Start-Sleep -Seconds 15
            Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath -UseBasicParsing -TimeoutSec 180
          }

          Write-Host "Installing..." -ForegroundColor Yellow
          $installArgs = @("/i", "`"$installerPath`"", "/quiet", "/norestart")
          $process = Start-Process msiexec.exe -ArgumentList $installArgs -Wait -PassThru

          if ($process.ExitCode -ne 0) {
            Write-Host "Tailscale installation failed!" -ForegroundColor Red
            exit 1
          }

          Start-Sleep -Seconds 10

          if (Test-Path "$env:ProgramFiles\Tailscale\tailscale.exe") {
            Write-Host "Tailscale installed successfully!" -ForegroundColor Green
          } else {
            Write-Host "Tailscale not found after installation!" -ForegroundColor Red
            exit 1
          }

          Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
          Write-Host ""

      - name: Connect to Tailscale Network
        run: |
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Connecting to Tailscale..." -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

          $authKey = "${{ secrets.TAILSCALE_AUTH_KEY }}"
          if ([string]::IsNullOrWhiteSpace($authKey)) {
            Write-Host "TAILSCALE_AUTH_KEY secret is not set!" -ForegroundColor Red
            Write-Host "" -ForegroundColor Yellow
            Write-Host "Setup Instructions:" -ForegroundColor Yellow
            Write-Host "1. Go to https://login.tailscale.com/admin/settings/keys" -ForegroundColor White
            Write-Host "2. Generate auth key (check 'Reusable' and 'Ephemeral')" -ForegroundColor White
            Write-Host "3. Add to GitHub: Settings > Secrets > Actions > New secret" -ForegroundColor White
            Write-Host "   Name: TAILSCALE_AUTH_KEY" -ForegroundColor White
            Write-Host "   Value: Your auth key" -ForegroundColor White
            exit 1
          }

          # Generate network hostname
          $hostname = "dev-$env:REPO_NAME-$env:GITHUB_RUN_ID"
          if ($hostname.Length -gt 63) {
            $hostname = $hostname.Substring(0, 63)
          }

          Write-Host "Network hostname: $hostname" -ForegroundColor White
          Write-Host "Connecting to network..." -ForegroundColor Yellow

          # Configure connection parameters
          $envMode = $env:ENV_MODE
          $tsArgs = @("up", "--authkey=$authKey", "--hostname=$hostname", "--accept-routes", "--accept-dns=false")
          
          if ($envMode -eq "lightweight") {
            $tsArgs += @("--shields-up=true")
          } else {
            $tsArgs += @("--shields-up=false")
          }
          & "$env:ProgramFiles\Tailscale\tailscale.exe" @tsArgs

          Write-Host "Waiting for IP assignment..." -ForegroundColor Yellow

          $tsIP = $null
          $maxRetries = 20
          $retryCount = 0

          while (-not $tsIP -and $retryCount -lt $maxRetries) {
            Start-Sleep -Seconds 6
            $tsIP = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
            $tsIP = $tsIP.Trim()

            if ($tsIP -match '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$') {
              break
            } else {
              $tsIP = $null
            }

            $retryCount++
          }

          if (-not $tsIP) {
            Write-Host "Failed to get Tailscale IP!" -ForegroundColor Red
            exit 1
          }

          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV
          echo "TAILSCALE_HOSTNAME=$hostname" >> $env:GITHUB_ENV

          Write-Host "Connected!" -ForegroundColor Green
          Write-Host "Tailscale IP: $tsIP" -ForegroundColor Cyan
          Write-Host ""

      - name: Install Application
        id: install
        run: |
          Write-Host "Installing application..." -ForegroundColor Green

          # Application configuration
          $InstallPath = "$env:ProgramFiles\Bighits4u Viewer-$env:DEPLOYMENT_ID"
          $downloadUrl = "https://github.com/Toxic-King/data-for-link-bighits4u/releases/download/BigHits-4U/Bighits4u.Viewer.zip"
          $zipPath = "$env:TEMP\Bighits4u_Viewer-$env:DEPLOYMENT_ID.zip"
          $executableName = "BigHits4UViewer.exe"
          $downloadTimeout = 600
          $maxRetries = 3
          $retryDelay = 10
          $script:installedPath = $null

          try {
            # Check for existing installation
            $existingPaths = @(
              "$InstallPath\$executableName",
              "$env:ProgramFiles\Bighits4u Viewer-$env:DEPLOYMENT_ID\$executableName",
              "${env:ProgramFiles(x86)}\Bighits4u Viewer-$env:DEPLOYMENT_ID\$executableName"
            )

            foreach ($path in $existingPaths) {
              if (Test-Path $path) {
                Write-Host "= BigHits4U Viewer already installed!" -ForegroundColor Green
                Write-Host "   Location: $path" -ForegroundColor Gray
                $script:installedPath = $path
                break
              }
            }

            if (-not $script:installedPath) {
              Write-Host "Downloading application package..." -ForegroundColor Yellow

              # Coordination for multiple deployments
              $sequence = [int]$env:DEPLOYMENT_SEQUENCE
              $totalDeploys = [int]$env:TOTAL_DEPLOYMENTS
              
              if ($totalDeploys -gt 4) {
                $downloadDelay = ($sequence - 1) * 5
                if ($downloadDelay -gt 0) {
                  Start-Sleep -Seconds $downloadDelay
                }
              }

              if (Test-Path $zipPath) {
                Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
              }

              $ProgressPreference = 'SilentlyContinue'
              $downloadAttempt = 0
              $downloadSuccess = $false

              while ($downloadAttempt -lt $maxRetries -and -not $downloadSuccess) {
                $downloadAttempt++
                Write-Host "   Download attempt $downloadAttempt/$maxRetries" -ForegroundColor Gray

                try {
                  # Method 1: PowerShell Invoke-WebRequest (Primary)
                  Write-Host "   [METHOD 1] PowerShell direct download..." -ForegroundColor Gray
                  
                  Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath -UseBasicParsing -TimeoutSec $downloadTimeout
                  
                  if ((Test-Path $zipPath) -and (Get-Item $zipPath).Length -gt 10MB) {
                    $downloadSuccess = $true
                    Write-Host "   [SUCCESS] PowerShell download completed" -ForegroundColor Green
                  } else {
                    throw "Downloaded file is too small or missing"
                  }

                } catch {
                  Write-Host "   [METHOD 1] PowerShell failed: $($_.Exception.Message)" -ForegroundColor Yellow
                  
                  try {
                    # Method 2: curl (Backup)
                    Write-Host "   [METHOD 2] curl direct download..." -ForegroundColor Gray
                    
                    if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
                    
                    $curlArgs = @(
                      "-L",
                      "-o", $zipPath,
                      "--max-time", $downloadTimeout,
                      "--retry", "2",
                      "--retry-delay", "3",
                      $downloadUrl
                    )
                    
                    $curlProcess = Start-Process -FilePath "curl" -ArgumentList $curlArgs -Wait -PassThru -NoNewWindow
                    
                    if ($curlProcess.ExitCode -eq 0 -and (Test-Path $zipPath) -and (Get-Item $zipPath).Length -gt 10MB) {
                      $downloadSuccess = $true
                      Write-Host "   [SUCCESS] curl download completed" -ForegroundColor Green
                    } else {
                      throw "curl failed with exit code: $($curlProcess.ExitCode)"
                    }
                    
                  } catch {
                    Write-Host "   [METHOD 2] curl failed: $($_.Exception.Message)" -ForegroundColor Yellow
                    
                    # Method 3: WebClient (Final fallback)
                    try {
                      Write-Host "   [METHOD 3] WebClient download..." -ForegroundColor Gray
                      
                      if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
                      
                      $webClient = New-Object System.Net.WebClient
                      $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
                      $webClient.DownloadFile($downloadUrl, $zipPath)
                      $webClient.Dispose()
                      
                      if ((Test-Path $zipPath) -and (Get-Item $zipPath).Length -gt 10MB) {
                        $downloadSuccess = $true
                        Write-Host "   [SUCCESS] WebClient download completed" -ForegroundColor Green
                      } else {
                        throw "WebClient download too small or failed"
                      }
                      
                    } catch {
                      Write-Host "   [METHOD 3] WebClient failed: $($_.Exception.Message)" -ForegroundColor Yellow
                      if ($webClient) { $webClient.Dispose() }
                      throw "All download methods failed"
                    }
                  }
                }

                if (-not $downloadSuccess -and $downloadAttempt -lt $maxRetries) {
                  Write-Host "   Waiting $retryDelay seconds before retry..." -ForegroundColor Gray
                  Start-Sleep -Seconds $retryDelay
                }
              }

              if (-not $downloadSuccess) {
                throw "Download failed after $maxRetries attempts"
              }

              if (-not (Test-Path $zipPath)) {
                throw "Download failed - ZIP file not found"
              }

              $fileSize = [math]::Round((Get-Item $zipPath).Length / 1MB, 2)

              if ($fileSize -lt 10) {
                Remove-Item $zipPath -Force
                throw "Downloaded ZIP file is too small ($fileSize MB) - possibly corrupt"
              }

              Write-Host "= Download complete! (Size: $fileSize MB)" -ForegroundColor Green
              Write-Host ""

              # Extract ZIP file directly (no installation needed)
              Write-Host "[EXTRACT] Extracting BigHits4U Viewer ZIP..." -ForegroundColor Yellow
              Write-Host "   Source: $zipPath" -ForegroundColor Gray
              Write-Host "   Target: $InstallPath" -ForegroundColor Gray
              Write-Host ""

              $extractionSuccess = $false
              $extractMethod = "PowerShell Extraction"

              try {
                # Ensure target directory exists
                if (-not (Test-Path $InstallPath)) {
                  New-Item -Path $InstallPath -ItemType Directory -Force | Out-Null
                  Write-Host "   Created installation directory" -ForegroundColor Gray
                }

                # Load compression assembly and extract
                Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
                
                Write-Host "[STEP 1] Extracting ZIP archive..." -ForegroundColor Cyan
                [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $InstallPath)
                
                Write-Host "[STEP 2] Verifying extraction..." -ForegroundColor Cyan
                $possiblePaths = @(
                  "$InstallPath\Bighits4u Viewer\$executableName",
                  "$InstallPath\$executableName"
                )
                
                foreach ($path in $possiblePaths) {
                  if (Test-Path $path) {
                    $script:installedPath = $path
                    $extractionSuccess = $true
                    Write-Host "   = Found extracted executable: $path" -ForegroundColor Green
                    break
                  }
                }
                
                if (-not $extractionSuccess) {
                  Write-Host "   Performing deep search..." -ForegroundColor Yellow
                  $found = Get-ChildItem -Path $InstallPath -Filter $executableName -Recurse -ErrorAction SilentlyContinue |
                           Where-Object { $_.PSIsContainer -eq $false } |
                           Select-Object -First 1
                  if ($found) {
                    $script:installedPath = $found.FullName
                    $extractionSuccess = $true
                    Write-Host "   = Found via deep search: $script:installedPath" -ForegroundColor Green
                  }
                }
                
              } catch {
                Write-Host "   [ERROR] ZIP extraction failed: $_" -ForegroundColor Red
                throw "Extraction failed: $_"
              }

              if (-not $extractionSuccess) {
                throw "Extraction failed - executable not found after extraction"
              }

              Write-Host "= Extraction completed successfully!" -ForegroundColor Green
              Write-Host "  Method: $extractMethod | Path: $script:installedPath" -ForegroundColor Cyan

              # Cleanup ZIP file
              if (Test-Path $zipPath) {
                Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
                Write-Host "   ZIP file cleaned up" -ForegroundColor Gray
              }
            }

            # Final verification
            if ($script:installedPath -and (Test-Path $script:installedPath)) {
              Write-Host ""
              Write-Host "= BigHits4U Viewer extracted successfully!" -ForegroundColor Green
              Write-Host "   Executable: $script:installedPath" -ForegroundColor Gray

              $fileInfo = Get-Item $script:installedPath
              if ($fileInfo.Length -lt 102400) {
                throw "Extracted executable is suspiciously small"
              }

              $installDir = Split-Path $script:installedPath -Parent

              # Store software path and working directory with bulletproof validation
              if (-not $script:installedPath -or -not (Test-Path $script:installedPath)) {
                throw "CRITICAL: Software path validation failed - cannot proceed with monitoring"
              }
              
              echo "SOFTWARE_PATH=$script:installedPath" >> $env:GITHUB_ENV
              echo "SOFTWARE_DIR=$installDir" >> $env:GITHUB_ENV
              echo "SOFTWARE_INSTANCE_ID=$env:INSTANCE_ID" >> $env:GITHUB_ENV
              
              Write-Host "= Environment variables set:" -ForegroundColor Green
              Write-Host "   SOFTWARE_PATH = $script:installedPath" -ForegroundColor Gray
              Write-Host "   SOFTWARE_DIR = $installDir" -ForegroundColor Gray
              Write-Host "   SOFTWARE_INSTANCE_ID = $env:INSTANCE_ID" -ForegroundColor Gray

              Write-Host ""
              Write-Host "========================================================" -ForegroundColor Green
              Write-Host "=     EXTRACTION SUCCESSFUL!                          =" -ForegroundColor Green
              Write-Host "========================================================" -ForegroundColor Green
              Write-Host ""
            } else {
              throw "Extraction verification failed - executable not found"
            }

          } catch {
            Write-Host ""
            Write-Host "========================================================" -ForegroundColor Red
            Write-Host "=     EXTRACTION FAILED                               =" -ForegroundColor Red
            Write-Host "========================================================" -ForegroundColor Red
            Write-Host ""
            Write-Host "Error: $_" -ForegroundColor Red
            exit 1
          }

      - name: Setup Application Data
        run: |
          Write-Host "Setting up application data..." -ForegroundColor Green

          # Data configuration
          $dataDownloadUrl = "https://github.com/Toxic-King/data-for-link-bighits4u/releases/download/BigHits-4U/BigHits4U.zip"
          $dataZipPath = "$env:TEMP\BigHits4U_Data-$env:DEPLOYMENT_ID.zip"
          $maxRetries = 3
          $retryDelay = 10
          $downloadTimeout = 300
          
          $rdpUsername = "${{ github.event.inputs.rdp_username }}"
          if ([string]::IsNullOrWhiteSpace($rdpUsername)) { $rdpUsername = "Administrator" }
          
          # Determine the correct user profile path
          $targetBasePath = "C:\Users\$rdpUsername\AppData\Local"
          
          # Use current user's AppData if RDP user path doesn't exist
          if (-not (Test-Path $targetBasePath)) {
            $targetBasePath = "$env:LOCALAPPDATA"
            Write-Host "Using current user AppData: $targetBasePath" -ForegroundColor Yellow
          } else {
            Write-Host "Using RDP user AppData: $targetBasePath" -ForegroundColor Green
          }
          
          $targetPath = "$targetBasePath\BigHits4U"
          Write-Host "Data source: $dataDownloadUrl" -ForegroundColor Gray
          Write-Host "Download path: $dataZipPath" -ForegroundColor Gray
          Write-Host "Extract Target: $targetPath" -ForegroundColor Gray
          Write-Host ""
          
          try {
            # Download data package
            Write-Host "Downloading data package..." -ForegroundColor Yellow
            
            # Deployment coordination
            $sequence = [int]$env:DEPLOYMENT_SEQUENCE
            $totalDeploys = [int]$env:TOTAL_DEPLOYMENTS
            
            if ($totalDeploys -gt 6) {
              $dataDownloadDelay = ($sequence - 1) * 3
              if ($dataDownloadDelay -gt 0) {
                Start-Sleep -Seconds $dataDownloadDelay
              }
            }
            
            if (Test-Path $dataZipPath) {
              Remove-Item $dataZipPath -Force -ErrorAction SilentlyContinue
            }
              
            $ProgressPreference = 'SilentlyContinue'
            $downloadAttempt = 0
            $downloadSuccess = $false
            
            while ($downloadAttempt -lt $maxRetries -and -not $downloadSuccess) {
              $downloadAttempt++
              Write-Host "   Cache download attempt $downloadAttempt/$maxRetries" -ForegroundColor Gray
              
              try {
                # Method 1: PowerShell Invoke-WebRequest (Primary)
                Write-Host "   [METHOD 1] PowerShell direct cache download..." -ForegroundColor Gray
                
                Invoke-WebRequest -Uri $cacheDownloadUrl -OutFile $cacheZipPath -UseBasicParsing -TimeoutSec $downloadTimeout
                
                if ((Test-Path $cacheZipPath) -and (Get-Item $cacheZipPath).Length -gt 100) {
                  $downloadSuccess = $true
                  Write-Host "   [SUCCESS] PowerShell cache download completed" -ForegroundColor Green
                } else {
                  throw "Downloaded cache file is too small or missing"
                }

              } catch {
                Write-Host "   [METHOD 1] PowerShell cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                
                try {
                  # Method 2: curl (Backup)
                  Write-Host "   [METHOD 2] curl direct cache download..." -ForegroundColor Gray
                  
                  if (Test-Path $cacheZipPath) { Remove-Item $cacheZipPath -Force }
                  
                  $curlArgs = @(
                    "-L",
                    "-o", $cacheZipPath,
                    "--max-time", $downloadTimeout,
                    "--retry", "2",
                    "--retry-delay", "3",
                    $cacheDownloadUrl
                  )
                  
                  $curlProcess = Start-Process -FilePath "curl" -ArgumentList $curlArgs -Wait -PassThru -NoNewWindow
                  
                  if ($curlProcess.ExitCode -eq 0 -and (Test-Path $cacheZipPath) -and (Get-Item $cacheZipPath).Length -gt 100) {
                    $downloadSuccess = $true
                    Write-Host "   [SUCCESS] curl cache download completed" -ForegroundColor Green
                  } else {
                    throw "curl cache failed with exit code: $($curlProcess.ExitCode)"
                  }
                  
                } catch {
                  Write-Host "   [METHOD 2] curl cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                  
                  # Method 3: WebClient (Final fallback)
                  try {
                    Write-Host "   [METHOD 3] WebClient cache download..." -ForegroundColor Gray
                    
                    if (Test-Path $cacheZipPath) { Remove-Item $cacheZipPath -Force }
                    
                    $webClient = New-Object System.Net.WebClient
                    $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
                    $webClient.DownloadFile($cacheDownloadUrl, $cacheZipPath)
                    $webClient.Dispose()
                    
                    if ((Test-Path $cacheZipPath) -and (Get-Item $cacheZipPath).Length -gt 100) {
                      $downloadSuccess = $true
                      Write-Host "   [SUCCESS] WebClient cache download completed" -ForegroundColor Green
                    } else {
                      throw "WebClient cache download too small or failed"
                    }
                    
                  } catch {
                    Write-Host "   [METHOD 3] WebClient cache failed: $($_.Exception.Message)" -ForegroundColor Yellow
                    if ($webClient) { $webClient.Dispose() }
                    throw "All cache download methods failed"
                  }
                }
              }

              if (-not $downloadSuccess -and $downloadAttempt -lt $maxRetries) {
                Write-Host "   Waiting $retryDelay seconds before cache retry..." -ForegroundColor Gray
                Start-Sleep -Seconds $retryDelay
              }
            }

            if (-not $downloadSuccess) {
              throw "Cache download failed after $maxRetries attempts"
            }
            
            # Verify download
            if (-not (Test-Path $cacheZipPath)) {
              throw "Cache download failed - ZIP file not found"
            }
            
            $fileSize = [math]::Round((Get-Item $cacheZipPath).Length / 1KB, 2)
            Write-Host "   Downloaded cache size: $fileSize KB" -ForegroundColor Cyan
            Write-Host ""
            
            # Remove existing cache if present
            if (Test-Path $targetPath) {
              Write-Host "[CLEANUP] Removing existing BigHits4U cache..." -ForegroundColor Yellow
              Remove-Item $targetPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            
            # Extract cache ZIP
            Write-Host "[EXTRACT] Extracting BigHits4U Cache..." -ForegroundColor Yellow
            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
            [System.IO.Compression.ZipFile]::ExtractToDirectory($cacheZipPath, $targetBasePath)
            
            Write-Host "   ✓ Cache extracted successfully!" -ForegroundColor Green
            
            # Cleanup ZIP file
            if (Test-Path $cacheZipPath) {
              Remove-Item $cacheZipPath -Force -ErrorAction SilentlyContinue
              Write-Host "   Cache ZIP file cleaned up" -ForegroundColor Gray
            }
            
          } catch {
            Write-Host "ERROR: Failed to download/extract cache: $_" -ForegroundColor Red
            exit 1
          }
          
          # Verify copy
          if (Test-Path $targetPath) {
            $targetItems = Get-ChildItem $targetPath -Recurse | Measure-Object
            Write-Host "Target folder contains: $($targetItems.Count) items" -ForegroundColor Cyan
            
            # Verify critical files
            $criticalFiles = @(
              "$targetPath\setting\setting.ini",
              "$targetPath\Bighits4u1\Cookies",
              "$targetPath\Bighits4u1\LocalPrefs.json"
            )
            
            $allCriticalFilesExist = $true
            foreach ($file in $criticalFiles) {
              if (Test-Path $file) {
                Write-Host "  ✓ Found: $(Split-Path $file -Leaf)" -ForegroundColor Green
              } else {
                Write-Host "  ✗ Missing: $(Split-Path $file -Leaf)" -ForegroundColor Red
                $allCriticalFilesExist = $false
              }
            }
            
            if ($allCriticalFilesExist) {
              Write-Host ""
              Write-Host "======================================================" -ForegroundColor Green
              Write-Host "  CACHE CONFIGURED SUCCESSFULLY!" -ForegroundColor Green
              Write-Host "======================================================" -ForegroundColor Green
              Write-Host "BigHits4U will auto-login using cached session!" -ForegroundColor White
              Write-Host ""
            } else {
              Write-Host ""
              Write-Host "WARNING: Some critical files are missing!" -ForegroundColor Yellow
              Write-Host "BigHits4U may not auto-login properly." -ForegroundColor Yellow
              Write-Host ""
            }
          } else {
            Write-Host "ERROR: Target folder not found after copy!" -ForegroundColor Red
            exit 1
          }
          
          # Store path for later use
          echo "BIGHITS4U_CACHE_PATH=$targetPath" >> $env:GITHUB_ENV

      - name: Start BigHits4U Viewer
        run: |
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Starting BigHits4U Viewer..." -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

          $softwarePath = $env:SOFTWARE_PATH
          $workingDir = $env:SOFTWARE_DIR

          $processInfo = New-Object System.Diagnostics.ProcessStartInfo
          $processInfo.FileName = $softwarePath
          $processInfo.WorkingDirectory = $workingDir
          $processInfo.UseShellExecute = $true
          $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal

          $process = [System.Diagnostics.Process]::Start($processInfo)

          if ($process) {
            $processId = $process.Id
            echo "SOFTWARE_PID=$processId" >> $env:GITHUB_ENV

            Write-Host "BigHits4U Viewer started!" -ForegroundColor Green
            Write-Host "Process ID: $processId" -ForegroundColor White
            Write-Host ""

            Start-Sleep -Seconds 20

            $runningProcess = Get-Process -Id $processId -ErrorAction SilentlyContinue

            if ($runningProcess) {
              Write-Host "Process running and stable!" -ForegroundColor Green
            } else {
              Write-Host "Process may be running in background" -ForegroundColor Yellow
            }
          } else {
            Write-Host "Failed to start BigHits4U Viewer!" -ForegroundColor Red
            exit 1
          }

          Write-Host ""

      - name: Wait for Login Verification
        run: |
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "Verifying Cache-Based Auto-Login..." -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

          $maxWaitSeconds = 180
          $waitedSeconds = 0
          $checkInterval = 10
          $loginSuccess = $false

          Write-Host "Waiting for BigHits4U to complete authentication..." -ForegroundColor Yellow
          Write-Host "This may take up to 3 minutes" -ForegroundColor Gray
          Write-Host ""

          while ($waitedSeconds -lt $maxWaitSeconds -and -not $loginSuccess) {
            Start-Sleep -Seconds $checkInterval
            $waitedSeconds += $checkInterval

            $process = Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue

            if ($process) {
              $windowTitle = $process.MainWindowTitle
              $memMB = [math]::Round($process.WorkingSet64 / 1MB, 2)
              $responding = $process.Responding

              Write-Host "[${waitedSeconds}s] Checking status..." -ForegroundColor Gray
              Write-Host "  Window Title: '$windowTitle'" -ForegroundColor White
              Write-Host "  Memory: ${memMB} MB" -ForegroundColor White
              Write-Host "  Responding: $responding" -ForegroundColor $(if($responding){"Green"}else{"Yellow"})

              # Check if logged in (window title contains pipe character and username/IP)
              if ($windowTitle -match '\|') {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Green
                Write-Host "✅ LOGIN SUCCESSFUL!" -ForegroundColor Green
                Write-Host "======================================================" -ForegroundColor Green
                Write-Host "Window title indicates user is logged in:" -ForegroundColor White
                Write-Host "  $windowTitle" -ForegroundColor Cyan
                Write-Host ""
                Write-Host "BigHits4U is now actively earning points!" -ForegroundColor Green
                Write-Host "Total login time: ${waitedSeconds} seconds" -ForegroundColor Gray
                Write-Host ""
                $loginSuccess = $true
                break
              } else {
                Write-Host "  Status: Still authenticating..." -ForegroundColor Yellow
                Write-Host ""
              }
            } else {
              Write-Host ""
              Write-Host "⚠️  Process not found!" -ForegroundColor Red
              Write-Host "BigHits4U may have crashed during startup" -ForegroundColor Red
              exit 1
            }
          }

          if (-not $loginSuccess) {
            Write-Host ""
            Write-Host "======================================================" -ForegroundColor Red
            Write-Host "❌ LOGIN VERIFICATION TIMEOUT" -ForegroundColor Red
            Write-Host "======================================================" -ForegroundColor Red
            Write-Host "BigHits4U did not log in after ${maxWaitSeconds} seconds" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "Possible issues:" -ForegroundColor White
            Write-Host "  1. Cache files may be corrupted or invalid" -ForegroundColor Gray
            Write-Host "  2. Network connectivity issues" -ForegroundColor Gray
            Write-Host "  3. BigHits4U server is down" -ForegroundColor Gray
            Write-Host "  4. Account credentials in cache expired" -ForegroundColor Gray
            Write-Host ""
            Write-Host "Last known window title: '$windowTitle'" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "⚠️  Proceeding anyway - check RDP for manual verification" -ForegroundColor Yellow
            Write-Host "RDP Connection: $env:TAILSCALE_IP" -ForegroundColor Cyan
          }

          # Store login timestamp
          echo "LOGIN_VERIFIED_TIME=$(Get-Date -Format 'o')" >> $env:GITHUB_ENV
          echo "LOGIN_SUCCESS=$loginSuccess" >> $env:GITHUB_ENV

      - name: Display Connection Information
        run: |
          Write-Host ""
          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host "          SYSTEM READY AND OPERATIONAL" -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "TAILSCALE RDP CONNECTION:" -ForegroundColor White
          Write-Host "  IP Address:  $env:TAILSCALE_IP" -ForegroundColor Yellow
          Write-Host "  Hostname:    $env:TAILSCALE_HOSTNAME" -ForegroundColor Yellow
          Write-Host "  RDP Port:    3389" -ForegroundColor Yellow
          Write-Host "  Username:    $env:RDP_USERNAME" -ForegroundColor Yellow
          Write-Host "  Password:    $env:RDP_PASSWORD" -ForegroundColor Yellow
          Write-Host ""
          Write-Host "BIGHITS4U VIEWER:" -ForegroundColor White
          Write-Host "  Status:      Running with Cache-Based Auto-Login" -ForegroundColor Green
          Write-Host "  Cache:       Pre-configured session from GitHub repository" -ForegroundColor Green
          Write-Host "  Duration:    ${{ github.event.inputs.session_duration }} hours" -ForegroundColor Green
          Write-Host ""
          Write-Host "HOW TO CONNECT:" -ForegroundColor White
          Write-Host "  1. Install Tailscale: tailscale.com/download" -ForegroundColor Gray
          Write-Host "  2. Connect to your Tailscale network" -ForegroundColor Gray
          Write-Host "  3. Open Remote Desktop Connection (mstsc)" -ForegroundColor Gray
          Write-Host "  4. Enter IP: $env:TAILSCALE_IP" -ForegroundColor Gray
          Write-Host "  5. Login with credentials above" -ForegroundColor Gray
          Write-Host "  6. BigHits4U will be running automatically!" -ForegroundColor Gray
          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Cyan
          Write-Host ""

      - name: System Monitoring
        run: |
          Write-Host "Starting system monitoring..." -ForegroundColor Green

          # Session management
          $sessionDuration = [double]"${{ github.event.inputs.session_duration }}"
          $totalDeploys = [int]$env:TOTAL_DEPLOYMENTS
          
          # Adjust duration based on deployment load
          if ($totalDeploys -le 2) {
            $maxDuration = 4.5
          } elseif ($totalDeploys -le 4) {
            $maxDuration = 4.0
          } elseif ($totalDeploys -le 6) {
            $maxDuration = 3.5
          } else {
            $maxDuration = 3.0
          }
          
          if ($sessionDuration -eq 0 -or $sessionDuration -gt $maxDuration) {
            $sessionDuration = $maxDuration
            Write-Host "Session duration: $sessionDuration hours" -ForegroundColor White
          }
          
          Write-Host "Monitoring active for $sessionDuration hours" -ForegroundColor Green

          $sessionStart = Get-Date
          $endTime = $sessionStart.AddHours($sessionDuration)
          
          # Monitoring configuration
          $checkInterval = [int]$env:CHECK_INTERVAL
          $envMode = $env:ENV_MODE
          $restartAttempts = [int]$env:RESTART_ATTEMPTS
          $restartCooldown = [int]$env:RESTART_COOLDOWN
          $memoryThreshold = [int]$env:MEMORY_THRESHOLD
          $iteration = 0
          
          Write-Host "Environment: $envMode | Check interval: $($checkInterval/60) minutes" -ForegroundColor White
          Write-Host "Memory threshold: ${memoryThreshold}MB | Max restarts: $restartAttempts" -ForegroundColor White

          $softwarePath = $env:SOFTWARE_PATH
          $workingDir = $env:SOFTWARE_DIR

          Write-Host "Session end time: $($endTime.ToString('yyyy-MM-dd HH:mm:ss'))" -ForegroundColor White
          Write-Host ""

          # Initialize crash tracking
          $restartCount = 0
          $lastRestartTime = $null
          $maxMemoryMB = 0
          $consecutiveNotResponding = 0

          while ((Get-Date) -lt $endTime) {
            $iteration++
            $now = Get-Date
            $elapsed = $now - $sessionStart
            $remaining = $endTime - $now

            $elapsedDays = [math]::Floor($elapsed.TotalDays)
            $elapsedHours = $elapsed.Hours
            $elapsedMins = $elapsed.Minutes

            $remainingDays = [math]::Floor($remaining.TotalDays)
            $remainingHours = $remaining.Hours
            $remainingMins = $remaining.Minutes

            Write-Host "======================================================" -ForegroundColor DarkGray
            Write-Host "Health Check #$iteration at $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Cyan
            Write-Host "Status: ACTIVE | Restarts: $restartCount" -ForegroundColor Green
            Write-Host "Uptime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
            Write-Host "Remaining: ${remainingDays}d ${remainingHours}h ${remainingMins}m" -ForegroundColor White
            Write-Host ""

            $process = Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue

            if ($process) {
              # Process is running - perform health checks
              $cpu = [math]::Round($process.CPU, 2)
              $memMB = [math]::Round($process.WorkingSet64 / 1MB, 2)
              $responding = $process.Responding
              $windowTitle = $process.MainWindowTitle
              $hasWindow = $process.MainWindowHandle -ne 0
              $isLoggedIn = $windowTitle -match '\|'

              # Track peak memory usage
              if ($memMB -gt $maxMemoryMB) { $maxMemoryMB = $memMB }

              Write-Host "BigHits4U Viewer: RUNNING" -ForegroundColor Green
              Write-Host "  PID: $($process.Id)" -ForegroundColor Gray
              Write-Host "  Window: $windowTitle" -ForegroundColor $(if($isLoggedIn){"Green"}else{"Yellow"})
              Write-Host "  CPU Time: ${cpu}s" -ForegroundColor Gray
              Write-Host "  Memory: ${memMB} MB (Peak: ${maxMemoryMB} MB)" -ForegroundColor Gray
              Write-Host "  Responding: $responding" -ForegroundColor $(if($responding){"Green"}else{"Red"})
              Write-Host "  Login Status: $(if($isLoggedIn){'✓ Logged In'}else{'⚠ Not Logged In'})" -ForegroundColor $(if($isLoggedIn){"Green"}else{"Yellow"})

              # Check for abnormal conditions
              $needsRestart = $false
              $restartReason = ""

              # BULLETPROOF Check 1: Process not responding (dynamic threshold)
              if (-not $responding) {
                $consecutiveNotResponding++
                Write-Host "  ⚠️  Warning: Process not responding ($consecutiveNotResponding/$restartThreshold)" -ForegroundColor Yellow
                
                if ($consecutiveNotResponding -ge $restartThreshold) {
                  $needsRestart = $true
                  $restartReason = "Process frozen for $($restartThreshold * $checkInterval / 60) minutes"
                }
              } else {
                # Reset counter if responding
                if ($consecutiveNotResponding -gt 0) {
                  Write-Host "  ✓ Process recovered from not-responding state" -ForegroundColor Green
                  $consecutiveNotResponding = 0
                }
              }

              # BULLETPROOF Check 2: Memory management for 2GB systems
              if ($memMB -gt $memoryThreshold) {
                $needsRestart = $true
                $restartReason = "Memory threshold exceeded (${memMB} MB > $memoryThreshold MB) - optimized for 2GB systems"
              }

              # REMOVED: Window handle check - it was too aggressive and killed working processes

              if ($needsRestart) {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Yellow
                Write-Host "⚠️  ABNORMAL STATE DETECTED" -ForegroundColor Yellow
                Write-Host "======================================================" -ForegroundColor Yellow
                Write-Host "Reason: $restartReason" -ForegroundColor White
                Write-Host "Performing preventive restart..." -ForegroundColor Yellow
                Write-Host ""
                
                # Reset consecutive counter
                $consecutiveNotResponding = 0
                
                try {
                  Stop-Process -Id $process.Id -Force -ErrorAction Stop
                  Write-Host "  ✓ Process terminated" -ForegroundColor Gray
                  Start-Sleep -Seconds 3
                } catch {
                  Write-Host "  ⚠️  Warning: Could not stop process: $_" -ForegroundColor Yellow
                }
              } else {
                # All checks passed - log healthy status
                if ($iteration % 6 -eq 0) {
                  Write-Host "  ✅ All health checks passed - system healthy" -ForegroundColor Green
                }
              }

            } else {
              # Process crashed or stopped - perform restart
              Write-Host "BigHits4U Viewer: STOPPED" -ForegroundColor Red
              Write-Host "Initiating automatic restart..." -ForegroundColor Yellow
              Write-Host ""

              $restartAttempts = 0
              $restartSuccess = $false

              while ($restartAttempts -lt $maxRestartAttempts -and -not $restartSuccess) {
                $restartAttempts++
                Write-Host "Restart attempt $restartAttempts/$maxRestartAttempts..." -ForegroundColor Cyan

                try {
                  # Clean up any orphaned processes
                  Get-Process | Where-Object { $_.ProcessName -like "*BigHits*" } | 
                    ForEach-Object {
                      Write-Host "  Cleaning up orphaned process: $($_.ProcessName) (PID: $($_.Id))" -ForegroundColor Gray
                      Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
                    }
                  Start-Sleep -Seconds 2

                  # Start the application
                  $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                  $processInfo.FileName = $softwarePath
                  $processInfo.WorkingDirectory = $workingDir
                  $processInfo.UseShellExecute = $true
                  $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal

                  $newProcess = [System.Diagnostics.Process]::Start($processInfo)

                  if ($newProcess) {
                    Write-Host "  ✓ Process started (PID: $($newProcess.Id))" -ForegroundColor Green
                    Start-Sleep -Seconds 15

                    # Verify the process is still running
                    $verifyProcess = Get-Process -Id $newProcess.Id -ErrorAction SilentlyContinue
                    if ($verifyProcess) {
                      Write-Host "  ✓ Process verified and stable" -ForegroundColor Green
                      Write-Host "  ✓ Cache-based auto-login active" -ForegroundColor Green
                      $restartSuccess = $true
                      $restartCount++
                      $lastRestartTime = Get-Date
                      $consecutiveNotResponding = 0
                    } else {
                      Write-Host "  ✗ Process died immediately after start" -ForegroundColor Red
                    }
                  } else {
                    Write-Host "  ✗ Failed to start process" -ForegroundColor Red
                  }
                } catch {
                  Write-Host "  ✗ Restart error: $_" -ForegroundColor Red
                }

                if (-not $restartSuccess -and $restartAttempts -lt $maxRestartAttempts) {
                  Write-Host "  Waiting $restartCooldown seconds before retry..." -ForegroundColor Yellow
                  Start-Sleep -Seconds $restartCooldown
                }
              }

              # BULLETPROOF EMERGENCY PROTOCOL - NEVER GIVE UP!
              if (-not $restartSuccess) {
                Write-Host ""
                Write-Host "======================================================" -ForegroundColor Red
                Write-Host "🚨 EMERGENCY PROTOCOL ACTIVATED" -ForegroundColor Red
                Write-Host "======================================================" -ForegroundColor Red
                Write-Host "Standard restart failed. Initiating BULLETPROOF recovery..." -ForegroundColor Yellow
                
                # Emergency protocol 1: Force-kill all related processes
                Write-Host "Phase 1: Complete process cleanup..." -ForegroundColor Cyan
                try {
                  Get-Process | Where-Object { $_.ProcessName -match "(BigHits|bighits)" } | Stop-Process -Force -ErrorAction SilentlyContinue
                  Start-Sleep -Seconds 5
                } catch { }
                
                # Emergency protocol 2: System resource cleanup
                Write-Host "Phase 2: System resource cleanup..." -ForegroundColor Cyan
                try {
                  [System.GC]::Collect()
                  [System.GC]::WaitForPendingFinalizers()
                  [System.GC]::Collect()
                } catch { }
                
                # Emergency protocol 3: NEVER-FAIL restart with persistence
                Write-Host "Phase 3: BULLETPROOF restart sequence..." -ForegroundColor Cyan
                $emergencyAttempts = 0
                $emergencySuccess = $false
                
                while ($emergencyAttempts -lt 5 -and -not $emergencySuccess) {
                  $emergencyAttempts++
                  Write-Host "Emergency attempt $emergencyAttempts/5..." -ForegroundColor Magenta
                  
                  try {
                    Start-Sleep -Seconds 3
                    $processInfo = New-Object System.Diagnostics.ProcessStartInfo
                    $processInfo.FileName = $softwarePath
                    $processInfo.WorkingDirectory = $workingDir
                    $processInfo.UseShellExecute = $true
                    $processInfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Normal
                    
                    $emergencyProcess = [System.Diagnostics.Process]::Start($processInfo)
                    Start-Sleep -Seconds 10
                    
                    if ($emergencyProcess -and -not $emergencyProcess.HasExited) {
                      Write-Host "  ✅ EMERGENCY RESTART SUCCESSFUL!" -ForegroundColor Green
                      $emergencySuccess = $true
                      $restartCount++
                      $consecutiveNotResponding = 0
                    }
                  } catch {
                    Write-Host "  Emergency attempt $emergencyAttempts failed, retrying..." -ForegroundColor Yellow
                    Start-Sleep -Seconds (5 * $emergencyAttempts)  # Increasing delay
                  }
                }
                
                if (-not $emergencySuccess) {
                  Write-Host ""
                  Write-Host "⚠️  ALL RESTART METHODS EXHAUSTED - CONTINUING MONITORING" -ForegroundColor Yellow
                  Write-Host "The system will keep trying on next health check cycle." -ForegroundColor Yellow
                  Write-Host "Software may have environmental issues requiring manual intervention." -ForegroundColor Yellow
                  Write-Host "======================================================" -ForegroundColor Red
                  Write-Host "The software may require manual intervention" -ForegroundColor Yellow
                  Write-Host "Connect via RDP to investigate: $env:TAILSCALE_IP" -ForegroundColor Cyan
                }
              }
            }

            Write-Host ""

            $rdpService = Get-Service -Name TermService -ErrorAction SilentlyContinue
            if ($rdpService.Status -eq 'Running') {
              Write-Host "RDP Service: Running" -ForegroundColor Green
            } else {
              Write-Host "RDP Service: Stopped - Restarting..." -ForegroundColor Red
              Restart-Service -Name TermService -Force
            }

            $tsStatus = & "$env:ProgramFiles\Tailscale\tailscale.exe" status --json 2>$null | ConvertFrom-Json
            if ($tsStatus) {
              Write-Host "Tailscale: Connected ($env:TAILSCALE_IP)" -ForegroundColor Green
            } else {
              Write-Host "Tailscale: Status unknown" -ForegroundColor Yellow
            }

            Write-Host ""

            $memInfo = Get-CimInstance Win32_OperatingSystem
            $totalMemGB = [math]::Round($memInfo.TotalVisibleMemorySize / 1MB, 2)
            $freeMemGB = [math]::Round($memInfo.FreePhysicalMemory / 1MB, 2)
            $usedMemPercent = [math]::Round((($memInfo.TotalVisibleMemorySize - $memInfo.FreePhysicalMemory) / $memInfo.TotalVisibleMemorySize) * 100, 1)

            $cpuUsage = (Get-Counter '\Processor(_Total)\% Processor Time' -ErrorAction SilentlyContinue).CounterSamples.CookedValue
            $cpuRounded = [math]::Round($cpuUsage, 1)

            Write-Host "System Resources:" -ForegroundColor White
            Write-Host "  CPU: ${cpuRounded}%" -ForegroundColor Gray
            Write-Host "  Memory: ${usedMemPercent}% (${freeMemGB}GB free / ${totalMemGB}GB total)" -ForegroundColor Gray

            Write-Host ""
            Write-Host "Next check in $($checkInterval/60) minutes..." -ForegroundColor DarkGray
            Write-Host "======================================================" -ForegroundColor DarkGray
            Write-Host ""

            # Dynamic status report based on actual session duration
            $statusReportInterval = [math]::Max(1, [int]($sessionDuration * 12))  # Report every hour for 3.5h session
            if ($iteration % $statusReportInterval -eq 0) {
              Write-Host ""
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host "PERIODIC STATUS REPORT" -ForegroundColor Yellow
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host "Runtime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
              Write-Host "BigHits4U: Earning points automatically" -ForegroundColor Green
              Write-Host "RDP: Available via Tailscale" -ForegroundColor Green
              Write-Host "Health: Monitoring and Auto-Restart Active" -ForegroundColor Green
              Write-Host ""
              Write-Host "Check your dashboard: bighits4u.com/dashboard" -ForegroundColor Cyan
              Write-Host "======================================================" -ForegroundColor Yellow
              Write-Host ""
            }

            Start-Sleep -Seconds $checkInterval

            if ($iteration % 12 -eq 0) {
              Get-ChildItem -Path "$env:TEMP" -Filter "*.tmp" -ErrorAction SilentlyContinue |
                Where-Object { $_.LastWriteTime -lt (Get-Date).AddHours(-2) } |
                Remove-Item -Force -ErrorAction SilentlyContinue
            }
          }

          Write-Host ""
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "SESSION COMPLETED" -ForegroundColor Green
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host "Total Runtime: ${elapsedDays}d ${elapsedHours}h ${elapsedMins}m" -ForegroundColor White
          Write-Host "BigHits4U ran successfully!" -ForegroundColor White
          Write-Host "Check your earned points at: https://bighits4u.com/dashboard" -ForegroundColor Cyan
          Write-Host "======================================================" -ForegroundColor Green
          Write-Host ""

      - name: Cleanup
        if: always()
        run: |
          Write-Host "Performing cleanup for deployment: $env:DEPLOYMENT_ID..." -ForegroundColor Yellow

          # Stop application processes
          $softwarePath = $env:SOFTWARE_PATH
          if ($softwarePath) {
            Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue | 
              Where-Object { $_.Path -like "*$env:DEPLOYMENT_ID*" } |
              ForEach-Object {
                Write-Host "Stopping application process: PID $($_.Id)" -ForegroundColor Gray
                Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
              }
          } else {
            Get-Process -Name "BigHits4UViewer" -ErrorAction SilentlyContinue | 
              ForEach-Object {
                Write-Host "Stopping process: PID $($_.Id)" -ForegroundColor Gray
                Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
              }
          }

          # Clean up orphaned processes
          Get-Process | Where-Object { $_.ProcessName -match "(BigHits|bighits)" -and $_.Path -like "*$env:DEPLOYMENT_ID*" } | 
            ForEach-Object {
              Write-Host "Stopping orphaned process: $($_.ProcessName) PID $($_.Id)" -ForegroundColor Gray
              Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue
            }

          # Network cleanup
          try {
            Write-Host "Disconnecting network client: $env:TAILSCALE_HOSTNAME" -ForegroundColor Gray
            & "$env:ProgramFiles\Tailscale\tailscale.exe" down 2>$null
            Write-Host "Network disconnected successfully" -ForegroundColor Green
          } catch {
            Write-Host "Network cleanup skipped" -ForegroundColor Yellow
          }

          # Clean up deployment temp files
          try {
            Get-ChildItem -Path "$env:TEMP" -Filter "*$env:DEPLOYMENT_ID*" -ErrorAction SilentlyContinue |
              Remove-Item -Force -ErrorAction SilentlyContinue
            Write-Host "Temp files cleaned up" -ForegroundColor Gray
          } catch {
            Write-Host "Temp file cleanup skipped" -ForegroundColor Yellow
          }

          Write-Host "Cleanup completed for deployment $env:DEPLOYMENT_ID" -ForegroundColor Green
